Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define external @Base$GetX i64(ptr %this) {
entry:
%0 = alloca i64
%1 = ptr add ptr %this, 0
%2 = load ptr, ptr %1
store ptr %2, ptr %0
br label exit
exit:
%3 = load i64, ptr %0
ret i64 %3
}


define external @Base$GetSum i64(ptr %this) {
entry:
br label entry.inlined
exit.inlined:
%0 = load i64, ptr %1
br label exit
entry.inlined:
%1 = alloca i64
%2 = ptr add ptr %this, 0
%3 = load ptr, ptr %2
store ptr %3, ptr %1
br label exit.inlined
exit:
ret i64 %0
}


define external @Derived$GetY i64(ptr %this) {
entry:
%0 = alloca i64
%1 = ptr add ptr %this, 8
%2 = load ptr, ptr %1
store ptr %2, ptr %0
br label exit
exit:
%3 = load i64, ptr %0
ret i64 %3
}


define external @Derived$GetSum i64(ptr %this) {
entry:
br label entry.inlined
entry.split:
%0 = call ptr %this, @Base$GetSum
%1 = add i64 %2, %0
br label exit
exit.inlined:
%2 = load i64, ptr %3
br label entry.split
entry.inlined:
%3 = alloca i64
%4 = ptr add ptr %this, 8
%5 = load ptr, ptr %4
store ptr %5, ptr %3
br label exit.inlined
exit:
ret i64 %1
}


define external @ExtendedDerived$GetZ i64(ptr %this) {
entry:
%0 = alloca i64
%1 = ptr add ptr %this, 16
%2 = load ptr, ptr %1
store ptr %2, ptr %0
br label exit
exit:
%3 = load i64, ptr %0
ret i64 %3
}


define external @ExtendedDerived$GetSum i64(ptr %this) {
entry:
br label entry.inlined
entry.split:
%0 = call ptr %this, @Derived$GetSum
%1 = add i64 %2, %0
br label exit
exit.inlined:
%2 = load i64, ptr %3
br label entry.split
entry.inlined:
%3 = alloca i64
%4 = ptr add ptr %this, 16
%5 = load ptr, ptr %4
store ptr %5, ptr %3
br label exit.inlined
exit:
ret i64 %1
}


define internal @PassBase__Base void(%Base %b) {
entry:
%0 = alloca %Base
store %Base %b, ptr %0
br label entry.inlined
entry.split:
%1 = icmp eq i64 %2, 1
call i8 %1, @Assert
%3 = call ptr %0, @Base$GetSum
%4 = icmp eq i64 %3, 1
call i8 %4, @Assert
br label exit
exit.inlined:
%2 = load i64, ptr %5
br label entry.split
entry.inlined:
%5 = alloca i64
%6 = ptr add ptr %0, 0
%7 = load ptr, ptr %6
store ptr %7, ptr %5
br label exit.inlined
exit:
ret 
}


define internal @PassBaseRef__Baseref void(ptr %b) {
entry:
br label entry.inlined
entry.split:
%0 = icmp eq i64 %1, 1
call i8 %0, @Assert
%2 = call ptr %b, @Base$GetSum
%3 = icmp eq i64 %2, 1
call i8 %3, @Assert
br label exit
exit.inlined:
%1 = load i64, ptr %4
br label entry.split
entry.inlined:
%4 = alloca i64
%5 = ptr add ptr %b, 0
%6 = load ptr, ptr %5
store ptr %6, ptr %4
br label exit.inlined
exit:
ret 
}


define internal @PassDerivedRef__Derivedref void(ptr %d) {
entry:
br label entry.inlined
entry.split:
%0 = icmp eq i64 %1, 1
call i8 %0, @Assert
br label entry.inlined1
entry.split.split:
%2 = icmp eq i64 %3, 2
call i8 %2, @Assert
%4 = call ptr %d, @Derived$GetSum
%5 = icmp eq i64 %4, 3
call i8 %5, @Assert
br label exit
exit.inlined:
%3 = load i64, ptr %6
br label entry.split.split
entry.inlined1:
%6 = alloca i64
%7 = ptr add ptr %d, 8
%8 = load ptr, ptr %7
store ptr %8, ptr %6
br label exit.inlined
exit.inlined1:
%1 = load i64, ptr %9
br label entry.split
entry.inlined:
%9 = alloca i64
%10 = ptr add ptr %d, 0
%11 = load ptr, ptr %10
store ptr %11, ptr %9
br label exit.inlined1
exit:
ret 
}


define internal @TestAssignment void() {
entry:
%0 = alloca %Derived
%1 = ptr add ptr %0, 0
store 1, ptr %1
%2 = ptr add ptr %0, 8
store 2, ptr %2
%3 = alloca %Base
%4 = ptr add ptr %3, 0
%5 = load i64, ptr %1
store i64 %5, ptr %4
br label entry.inlined
entry.split:
%6 = icmp eq i64 %7, 1
call i8 %6, @Assert
%8 = call ptr %3, @Base$GetSum
%9 = icmp eq i64 %8, 1
call i8 %9, @Assert
%10 = load %Base, ptr %3
call %Base %10, @PassBase__Base
call ptr %3, @PassBaseRef__Baseref
%11 = alloca %ExtendedDerived
%12 = ptr add ptr %11, 8
store 2, ptr %12
%13 = ptr add ptr %11, 0
store 1, ptr %13
%14 = ptr add ptr %11, 16
store 3, ptr %14
%15 = call ptr %11, @ExtendedDerived$GetSum
%16 = icmp eq i64 %15, 6
call i8 %16, @Assert
br label entry.inlined1
entry.split.split:
%17 = icmp eq i64 %18, 3
call i8 %17, @Assert
%19 = alloca %Base
%20 = ptr add ptr %19, 0
%21 = load i64, ptr %13
store i64 %21, ptr %20
br label entry.inlined2
entry.split.split.split:
%22 = icmp eq i64 %23, 1
call i8 %22, @Assert
%24 = call ptr %19, @Base$GetSum
%25 = icmp eq i64 %24, 1
call i8 %25, @Assert
%26 = load %Base, ptr %19
call %Base %26, @PassBase__Base
call ptr %19, @PassBaseRef__Baseref
%27 = alloca %Derived
%28 = ptr add ptr %27, 0
store i64 %21, ptr %28
%29 = ptr add ptr %27, 8
%30 = load i64, ptr %12
store i64 %30, ptr %29
br label entry.inlined3
entry.split.split.split.split:
%31 = icmp eq i64 %32, 1
call i8 %31, @Assert
br label entry.inlined4
entry.split.split.split.split.split:
%33 = icmp eq i64 %34, 2
call i8 %33, @Assert
%35 = call ptr %27, @Derived$GetSum
%36 = icmp eq i64 %35, 3
call i8 %36, @Assert
call ptr %27, @PassDerivedRef__Derivedref
br label exit
exit.inlined:
%34 = load i64, ptr %37
br label entry.split.split.split.split.split
entry.inlined4:
%37 = alloca i64
%38 = load ptr, ptr %29
store ptr %38, ptr %37
br label exit.inlined
exit.inlined1:
%32 = load i64, ptr %39
br label entry.split.split.split.split
entry.inlined3:
%39 = alloca i64
%40 = ptr add ptr %27, 0
%41 = load ptr, ptr %40
store ptr %41, ptr %39
br label exit.inlined1
exit.inlined2:
%23 = load i64, ptr %42
br label entry.split.split.split
entry.inlined2:
%42 = alloca i64
%43 = load ptr, ptr %20
store ptr %43, ptr %42
br label exit.inlined2
exit.inlined3:
%18 = load i64, ptr %44
br label entry.split.split
entry.inlined1:
%44 = alloca i64
%45 = load ptr, ptr %14
store ptr %45, ptr %44
br label exit.inlined3
exit.inlined4:
%7 = load i64, ptr %46
br label entry.split
entry.inlined:
%46 = alloca i64
%47 = load ptr, ptr %4
store ptr %47, ptr %46
br label exit.inlined4
exit:
ret 
}


define internal @TestReferenceAssignment void() {
entry:
%0 = alloca %Derived
%1 = ptr add ptr %0, 0
store 1, ptr %1
%2 = ptr add ptr %0, 8
store 2, ptr %2
%3 = alloca ptr
store ptr %0, ptr %3
%4 = load ptr, ptr %3
br label entry.inlined
entry.split:
%5 = icmp eq i64 %6, 1
call i8 %5, @Assert
%7 = call ptr %4, @Base$GetSum
%8 = icmp eq i64 %7, 1
call i8 %8, @Assert
%9 = alloca %ExtendedDerived
%10 = ptr add ptr %9, 8
store 2, ptr %10
%11 = ptr add ptr %9, 0
store 1, ptr %11
%12 = ptr add ptr %9, 16
store 3, ptr %12
%13 = alloca ptr
store ptr %9, ptr %13
%14 = load ptr, ptr %13
br label entry.inlined1
entry.split.split:
%15 = icmp eq i64 %16, 1
call i8 %15, @Assert
%17 = call ptr %14, @Base$GetSum
%18 = icmp eq i64 %17, 1
call i8 %18, @Assert
%19 = alloca ptr
store ptr %9, ptr %19
%20 = load ptr, ptr %19
br label entry.inlined2
entry.split.split.split:
%21 = icmp eq i64 %22, 1
call i8 %21, @Assert
br label entry.inlined3
entry.split.split.split.split:
%23 = icmp eq i64 %24, 2
call i8 %23, @Assert
%25 = call ptr %20, @Derived$GetSum
%26 = icmp eq i64 %25, 3
call i8 %26, @Assert
%27 = alloca %Base
%28 = ptr add ptr %27, 0
%29 = ptr add ptr %20, 0
%30 = load i64, ptr %29
store i64 %30, ptr %28
br label entry.inlined4
entry.split.split.split.split.split:
%31 = icmp eq i64 %32, 1
call i8 %31, @Assert
%33 = call ptr %27, @Base$GetSum
%34 = icmp eq i64 %33, 1
call i8 %34, @Assert
%35 = load %Base, ptr %27
call %Base %35, @PassBase__Base
call ptr %27, @PassBaseRef__Baseref
br label exit
exit.inlined:
%32 = load i64, ptr %36
br label entry.split.split.split.split.split
entry.inlined4:
%36 = alloca i64
%37 = load ptr, ptr %28
store ptr %37, ptr %36
br label exit.inlined
exit.inlined1:
%24 = load i64, ptr %38
br label entry.split.split.split.split
entry.inlined3:
%38 = alloca i64
%39 = ptr add ptr %20, 8
%40 = load ptr, ptr %39
store ptr %40, ptr %38
br label exit.inlined1
exit.inlined2:
%22 = load i64, ptr %41
br label entry.split.split.split
entry.inlined2:
%41 = alloca i64
%42 = ptr add ptr %20, 0
%43 = load ptr, ptr %42
store ptr %43, ptr %41
br label exit.inlined2
exit.inlined3:
%16 = load i64, ptr %44
br label entry.split.split
entry.inlined1:
%44 = alloca i64
%45 = ptr add ptr %14, 0
%46 = load ptr, ptr %45
store ptr %46, ptr %44
br label exit.inlined3
exit.inlined4:
%6 = load i64, ptr %47
br label entry.split
entry.inlined:
%47 = alloca i64
%48 = ptr add ptr %4, 0
%49 = load ptr, ptr %48
store ptr %49, ptr %47
br label exit.inlined4
exit:
ret 
}


define external @main i64() {
entry:
call ptr @TestAssignment
call ptr @TestReferenceAssignment
br label exit
exit:
ret i64 0
}

