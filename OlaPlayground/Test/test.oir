Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define external @S$Init__I__I void(ptr %this,i64 %x,i64 %y) {
entry:
%0 = ptr add ptr %this, 0
store i64 %x, ptr %0
%1 = ptr add ptr %this, 8
store i64 %y, ptr %1
br label exit
exit:
ret 
}


define external @S$SetX__I void(ptr %this,i64 %x) {
entry:
%0 = ptr add ptr %this, 0
store i64 %x, ptr %0
br label exit
exit:
ret 
}


define external @S$SetY__I void(ptr %this,i64 %y) {
entry:
%0 = ptr add ptr %this, 8
store i64 %y, ptr %0
br label exit
exit:
ret 
}


define external @S$GetX i64(ptr %this) {
entry:
%0 = alloca i64
%1 = ptr add ptr %this, 0
%2 = load ptr, ptr %1
store ptr %2, ptr %0
br label exit
exit:
%3 = load i64, ptr %0
ret i64 %3
}


define external @S$GetY i64(ptr %this) {
entry:
%0 = alloca i64
%1 = ptr add ptr %this, 8
%2 = load ptr, ptr %1
store ptr %2, ptr %0
br label exit
exit:
%3 = load i64, ptr %0
ret i64 %3
}


define internal @StructByValue__S void(%S %s) {
entry:
%0 = alloca %S
br label entry.inlined
entry.split.split.split:
%1 = icmp eq i64 %2, 100
call i8 %1, @Assert
br label entry.inlined1
entry.split.split.split.split:
%3 = icmp eq i64 %4, 100
call i8 %3, @Assert
br label exit
exit.inlined:
%4 = load i64, ptr %5
br label entry.split.split.split.split
entry.inlined1:
%5 = alloca i64
%6 = load ptr, ptr %7
store ptr %6, ptr %5
br label exit.inlined
exit.inlined1:
%2 = load i64, ptr %8
br label entry.split.split.split
entry.inlined2:
%8 = alloca i64
%9 = load ptr, ptr %10
store ptr %9, ptr %8
br label exit.inlined1
entry.inlined3:
%7 = ptr add ptr %0, 8
store 100, ptr %7
br label entry.inlined2
entry.inlined:
%10 = ptr add ptr %0, 0
store 100, ptr %10
br label entry.inlined3
exit:
ret 
}


define internal @StructByRef__Sref void(ptr %s) {
entry:
br label entry.inlined
entry.split.split.split:
%0 = icmp eq i64 %1, 1000
call i8 %0, @Assert
br label entry.inlined1
entry.split.split.split.split:
%2 = icmp eq i64 %3, 1000
call i8 %2, @Assert
br label exit
exit.inlined:
%3 = load i64, ptr %4
br label entry.split.split.split.split
entry.inlined1:
%4 = alloca i64
%5 = load ptr, ptr %6
store ptr %5, ptr %4
br label exit.inlined
exit.inlined1:
%1 = load i64, ptr %7
br label entry.split.split.split
entry.inlined2:
%7 = alloca i64
%8 = load ptr, ptr %9
store ptr %8, ptr %7
br label exit.inlined1
entry.inlined3:
%6 = ptr add ptr %s, 8
store 1000, ptr %6
br label entry.inlined2
entry.inlined:
%9 = ptr add ptr %s, 0
store 1000, ptr %9
br label entry.inlined3
exit:
ret 
}


define external @main i64() {
entry:
%0 = alloca %S
%1 = ptr add ptr %0, 0
store 0, ptr %1
%2 = ptr add ptr %0, 8
store 0, ptr %2
br label entry.inlined
entry.split:
%3 = load %S, ptr %0
call %S %3, @StructByValue__S
br label entry.inlined1
entry.split.split:
%4 = icmp eq i64 %5, 10
call i8 %4, @Assert
br label entry.inlined2
entry.split.split.split:
%6 = icmp eq i64 %7, 10
call i8 %6, @Assert
%8 = alloca %S
%9 = ptr add ptr %8, 0
%10 = load i64, ptr %1
store i64 %10, ptr %9
%11 = ptr add ptr %8, 8
%12 = load i64, ptr %2
store i64 %12, ptr %11
br label entry.inlined3
entry.split.split.split.split.split.split:
%13 = icmp eq i64 %14, 10
call i8 %13, @Assert
br label entry.inlined4
entry.split.split.split.split.split.split.split:
%15 = icmp eq i64 %16, 10
call i8 %15, @Assert
br label entry.inlined5
entry.split.split.split.split.split.split.split.split:
%17 = icmp eq i64 %18, 25
call i8 %17, @Assert
br label entry.inlined6
entry.split.split.split.split.split.split.split.split.split:
%19 = icmp eq i64 %20, 25
call i8 %19, @Assert
call ptr %0, @StructByRef__Sref
br label entry.inlined7
entry.split.split.split.split.split.split.split.split.split.split:
%21 = icmp eq i64 %22, 1000
call i8 %21, @Assert
br label entry.inlined8
entry.split.split.split.split.split.split.split.split.split.split.split:
%23 = icmp eq i64 %24, 1000
call i8 %23, @Assert
br label entry.inlined9
entry.split.split.split.split.split.split.split.split.split.split.split.split:
%25 = icmp eq i64 %26, 1000
call i8 %25, @Assert
br label entry.inlined10
entry.split.split.split.split.split.split.split.split.split.split.split.split.split:
%27 = icmp eq i64 %28, 1000
call i8 %27, @Assert
br label entry.inlined11
entry.split.split.split.split.split.split.split.split.split.split.split.split.split.split.split:
%29 = icmp eq i64 %30, 0
call i8 %29, @Assert
br label exit
exit.inlined:
%30 = load i64, ptr %31
br label entry.split.split.split.split.split.split.split.split.split.split.split.split.split.split.split
entry.inlined12:
%31 = alloca i64
%32 = load ptr, ptr %1
store ptr %32, ptr %31
br label exit.inlined
entry.inlined11:
store 0, ptr %1
br label entry.inlined12
exit.inlined1:
%28 = load i64, ptr %33
br label entry.split.split.split.split.split.split.split.split.split.split.split.split.split
entry.inlined10:
%33 = alloca i64
store ptr %34, ptr %33
br label exit.inlined1
exit.inlined2:
%26 = load i64, ptr %35
br label entry.split.split.split.split.split.split.split.split.split.split.split.split
entry.inlined9:
%35 = alloca i64
store ptr %36, ptr %35
br label exit.inlined2
exit.inlined3:
%24 = load i64, ptr %37
br label entry.split.split.split.split.split.split.split.split.split.split.split
entry.inlined8:
%37 = alloca i64
store ptr %34, ptr %37
br label exit.inlined3
exit.inlined4:
%22 = load i64, ptr %38
br label entry.split.split.split.split.split.split.split.split.split.split
entry.inlined7:
%38 = alloca i64
store ptr %36, ptr %38
br label exit.inlined4
exit.inlined5:
%20 = load i64, ptr %39
br label entry.split.split.split.split.split.split.split.split.split
entry.inlined6:
%39 = alloca i64
%34 = load ptr, ptr %2
store ptr %34, ptr %39
br label exit.inlined5
exit.inlined6:
%18 = load i64, ptr %40
br label entry.split.split.split.split.split.split.split.split
entry.inlined5:
%40 = alloca i64
%36 = load ptr, ptr %1
store ptr %36, ptr %40
br label exit.inlined6
exit.inlined7:
%16 = load i64, ptr %41
br label entry.split.split.split.split.split.split.split
entry.inlined4:
%41 = alloca i64
%42 = load ptr, ptr %11
store ptr %42, ptr %41
br label exit.inlined7
exit.inlined8:
%14 = load i64, ptr %43
br label entry.split.split.split.split.split.split
entry.inlined13:
%43 = alloca i64
%44 = load ptr, ptr %9
store ptr %44, ptr %43
br label exit.inlined8
entry.inlined14:
store 25, ptr %2
br label entry.inlined13
entry.inlined3:
store 25, ptr %1
br label entry.inlined14
exit.inlined9:
%7 = load i64, ptr %45
br label entry.split.split.split
entry.inlined2:
%45 = alloca i64
%46 = load ptr, ptr %2
store ptr %46, ptr %45
br label exit.inlined9
exit.inlined10:
%5 = load i64, ptr %47
br label entry.split.split
entry.inlined1:
%47 = alloca i64
%48 = load ptr, ptr %1
store ptr %48, ptr %47
br label exit.inlined10
entry.inlined:
store 10, ptr %1
store 10, ptr %2
br label entry.split
exit:
ret i64 0
}

