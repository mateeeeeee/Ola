Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @TestWhile i64() {
entry:
br label while.cond
while.cond:
%0 = phi i64 [ 0, entry ], [ %1, if.end ]
%2 = icmp slt i64 %0, 10
br i8 %2, label while.body, label while.end
while.body:
%3 = icmp eq i64 %0, 5
br i8 %3, label if.then, label if.end
while.end:
br label exit
if.then:
%4 = add i64 %0, %0
br label exit
if.end:
%1 = add i64 %0, 1
br label while.cond
exit:
%5 = phi i64 [ %4, if.then ], [ 0, while.end ]
ret i64 %5
}


define internal @TestEarlyReturnInLoop i64() {
entry:
%0 = alloca ptr
br label for.cond
for.body:
%1 = icmp eq i64 %2, 5
br i8 %1, label if.then, label for.iter
for.cond:
%2 = phi i64 [ 0, entry ], [ %3, for.iter ]
%4 = icmp slt i64 %2, 10
br i8 %4, label for.body, label for.end
for.iter:
store i64 %2, ptr %0
%3 = add i64 %2, 1
br label for.cond
for.end:
br label exit
if.then:
br label exit
exit:
%5 = phi i64 [ %2, if.then ], [ -1, for.end ]
ret i64 %5
}


define internal @TestNestedReturn i64() {
entry:
%0 = alloca ptr
%1 = alloca ptr
br label for.cond
for.body:
%2 = icmp eq i64 %3, 1
br i8 %2, label if.then, label for.iter
for.cond:
%3 = phi i64 [ 0, entry ], [ %4, for.iter ]
%5 = icmp slt i64 %3, 3
br i8 %5, label for.body, label for.end
for.iter:
store i64 %3, ptr %0
%4 = add i64 %3, 1
br label for.cond
for.end:
br label exit
if.then:
br label for.cond1
for.body1:
%6 = icmp eq i64 %7, 1
br i8 %6, label if.then1, label for.iter1
for.cond1:
%7 = phi i64 [ 0, if.then ], [ %8, for.iter1 ]
%9 = icmp slt i64 %7, 2
br i8 %9, label for.body1, label for.iter
for.iter1:
store i64 %7, ptr %1
%8 = add i64 %7, 1
br label for.cond1
if.then1:
%10 = smul i64 %3, %7
br label exit
exit:
%11 = phi i64 [ -1, for.end ], [ %10, if.then1 ]
ret i64 %11
}


define internal @TestVoidWithEarlyReturn void() {
entry:
%0 = alloca ptr
br label for.cond
for.body:
%1 = add i64 %2, %3
%4 = icmp sgt i64 %1, 30
br i8 %4, label if.then, label for.iter
for.cond:
%3 = phi i64 [ 1, entry ], [ %5, for.iter ]
%2 = phi i64 [ 0, entry ], [ %1, for.iter ]
%6 = icmp sle i64 %3, 10
br i8 %6, label for.body, label for.end
for.iter:
store i64 %3, ptr %0
%5 = add i64 %3, 1
br label for.cond
for.end:
call i8 0, @Assert
br label exit
if.then:
br label exit
exit:
ret 
}


define external @main i64() {
entry:
br label entry.split
entry.split:
call i8 1, @Assert
%0 = call ptr @TestWhile
%1 = icmp eq i64 %0, 10
call i8 %1, @Assert
br label entry.split.split
entry.split.split:
call i8 1, @Assert
%2 = call ptr @TestEarlyReturnInLoop
%3 = icmp eq i64 %2, 5
call i8 %3, @Assert
%4 = call ptr @TestNestedReturn
%5 = icmp eq i64 %4, 1
call i8 %5, @Assert
call ptr @TestVoidWithEarlyReturn
br label exit
exit:
ret i64 0
}

