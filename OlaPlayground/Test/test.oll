Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @TestForLoopInt void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 1, ptr %1
br label for.cond
for.body:
%2 = load i64, ptr %0
%3 = load i64, ptr %1
%4 = add i64 %2, %3
store i64 %4, ptr %0
br label for.iter
for.cond:
%5 = load i64, ptr %1
%6 = icmp sle i64 %5, 5
br i8 %6, label for.body, label for.end
for.iter:
%7 = load i64, ptr %1
%8 = alloca ptr
store i64 %7, ptr %8
%9 = add i64 %7, 1
store i64 %9, ptr %1
br label for.cond
for.end:
%10 = load i64, ptr %0
%11 = icmp eq i64 %10, 15
call i8 %11, @Assert
br label exit
exit:
ret 
}


define internal @TestForLoopManualIncrement void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 1, ptr %1
br label for.cond
for.body:
%2 = load i64, ptr %0
%3 = load i64, ptr %1
%4 = add i64 %2, %3
store i64 %4, ptr %0
%5 = load i64, ptr %1
%6 = add i64 %5, 2
store i64 %6, ptr %1
br label for.iter
for.cond:
%7 = load i64, ptr %1
%8 = icmp sle i64 %7, 5
br i8 %8, label for.body, label for.end
for.iter:
br label for.cond
for.end:
%9 = load i64, ptr %0
%10 = icmp eq i64 %9, 9
call i8 %10, @Assert
br label exit
exit:
ret 
}


define internal @TestForLoopMultipleExpressions void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 1, ptr %1
%2 = alloca i64
store 5, ptr %2
br label for.cond
for.body:
%3 = load i64, ptr %1
%4 = load i64, ptr %2
%5 = add i64 %3, %4
%6 = load i64, ptr %0
%7 = add i64 %6, %5
store i64 %7, ptr %0
br label for.iter
for.cond:
%8 = load i64, ptr %1
%9 = icmp sle i64 %8, 3
br i8 %9, label for.body, label for.end
for.iter:
%10 = load i64, ptr %1
%11 = alloca ptr
store i64 %10, ptr %11
%12 = add i64 %10, 1
store i64 %12, ptr %1
%13 = load i64, ptr %2
%14 = alloca ptr
store i64 %13, ptr %14
%15 = sub i64 %13, 1
store i64 %15, ptr %2
%16 = load i64, ptr %11
%17 = load i64, ptr %14
br label for.cond
for.end:
%18 = load i64, ptr %0
%19 = icmp eq i64 %18, 18
call i8 %19, @Assert
br label exit
exit:
ret 
}


define internal @TestNestedForLoops void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
%2 = alloca i64
store 0, ptr %2
br label for.cond
for.body:
br label for.cond1
for.cond:
%3 = load i64, ptr %0
%4 = icmp slt i64 %3, 3
br i8 %4, label for.body, label for.end
for.iter:
%5 = load i64, ptr %0
%6 = alloca ptr
store i64 %5, ptr %6
%7 = add i64 %5, 1
store i64 %7, ptr %0
br label for.cond
for.end:
%8 = load i64, ptr %0
%9 = icmp eq i64 %8, 3
call i8 %9, @Assert
%10 = load i64, ptr %1
%11 = icmp eq i64 %10, 2
call i8 %11, @Assert
br label exit
for.body1:
%12 = load i64, ptr %2
%13 = add i64 %12, 1
store i64 %13, ptr %2
br label for.iter1
for.cond1:
%14 = load i64, ptr %1
%15 = icmp slt i64 %14, 2
br i8 %15, label for.body1, label for.end1
for.iter1:
%16 = load i64, ptr %1
%17 = alloca ptr
store i64 %16, ptr %17
%18 = add i64 %16, 1
store i64 %18, ptr %1
br label for.cond1
for.end1:
br label for.iter
exit:
ret 
}


define internal @TestNestedForLoopsReset void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
br label for.cond
for.body:
%2 = alloca i64
store 0, ptr %2
br label for.cond1
for.cond:
%3 = load i64, ptr %0
%4 = icmp slt i64 %3, 3
br i8 %4, label for.body, label for.end
for.iter:
%5 = load i64, ptr %0
%6 = alloca ptr
store i64 %5, ptr %6
%7 = add i64 %5, 1
store i64 %7, ptr %0
br label for.cond
for.end:
%8 = load i64, ptr %0
%9 = icmp eq i64 %8, 3
call i8 %9, @Assert
%10 = load i64, ptr %1
%11 = icmp eq i64 %10, 6
call i8 %11, @Assert
br label exit
for.body1:
%12 = load i64, ptr %1
%13 = alloca ptr
store i64 %12, ptr %13
%14 = add i64 %12, 1
store i64 %14, ptr %1
br label for.iter1
for.cond1:
%15 = load i64, ptr %2
%16 = icmp slt i64 %15, 2
br i8 %16, label for.body1, label for.end1
for.iter1:
%17 = load i64, ptr %2
%18 = alloca ptr
store i64 %17, ptr %18
%19 = add i64 %17, 1
store i64 %19, ptr %2
br label for.cond1
for.end1:
br label for.iter
exit:
ret 
}


define internal @TestForLoopWithBreak void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 1, ptr %1
br label for.cond
for.body:
%2 = load i64, ptr %0
%3 = load i64, ptr %1
%4 = add i64 %2, %3
store i64 %4, ptr %0
%5 = load i64, ptr %1
%6 = icmp eq i64 %5, 3
br i8 %6, label if.then, label if.end
for.cond:
%7 = load i64, ptr %1
%8 = icmp sle i64 %7, 5
br i8 %8, label for.body, label for.end
for.iter:
%9 = load i64, ptr %1
%10 = alloca ptr
store i64 %9, ptr %10
%11 = add i64 %9, 1
store i64 %11, ptr %1
br label for.cond
for.end:
%12 = load i64, ptr %0
%13 = icmp eq i64 %12, 6
call i8 %13, @Assert
br label exit
if.then:
br label for.end
if.else:
br label exit
if.end:
br label for.iter
break:
br label exit
exit:
ret 
}


define internal @TestForLoopWithContinue void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 1, ptr %1
br label for.cond
for.body:
%2 = load i64, ptr %1
%3 = icmp eq i64 %2, 3
br i8 %3, label if.then, label if.end
for.cond:
%4 = load i64, ptr %1
%5 = icmp sle i64 %4, 5
br i8 %5, label for.body, label for.end
for.iter:
%6 = load i64, ptr %1
%7 = alloca ptr
store i64 %6, ptr %7
%8 = add i64 %6, 1
store i64 %8, ptr %1
br label for.cond
for.end:
%9 = load i64, ptr %0
%10 = icmp eq i64 %9, 12
call i8 %10, @Assert
br label exit
if.then:
br label for.iter
if.else:
br label exit
if.end:
%11 = load i64, ptr %0
%12 = load i64, ptr %1
%13 = add i64 %11, %12
store i64 %13, ptr %0
br label for.iter
continue:
br label exit
exit:
ret 
}


define internal @TestForLoopEmptyBody void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
br label for.cond
for.body:
br label for.iter
for.cond:
%2 = load i64, ptr %1
%3 = icmp slt i64 %2, 5
br i8 %3, label for.body, label for.end
for.iter:
%4 = load i64, ptr %1
%5 = alloca ptr
store i64 %4, ptr %5
%6 = add i64 %4, 1
store i64 %6, ptr %1
br label for.cond
for.end:
%7 = load i64, ptr %0
%8 = icmp eq i64 %7, 0
call i8 %8, @Assert
%9 = load i64, ptr %1
%10 = icmp eq i64 %9, 5
call i8 %10, @Assert
br label exit
exit:
ret 
}


define internal @TestForLoopNeverExecutes void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 10, ptr %1
br label for.cond
for.body:
%2 = load i64, ptr %0
%3 = load i64, ptr %1
%4 = add i64 %2, %3
store i64 %4, ptr %0
br label for.iter
for.cond:
%5 = load i64, ptr %1
%6 = icmp slt i64 %5, 5
br i8 %6, label for.body, label for.end
for.iter:
%7 = load i64, ptr %1
%8 = alloca ptr
store i64 %7, ptr %8
%9 = add i64 %7, 1
store i64 %9, ptr %1
br label for.cond
for.end:
%10 = load i64, ptr %0
%11 = icmp eq i64 %10, 0
call i8 %11, @Assert
br label exit
exit:
ret 
}


define internal @TestForLoopFloatCondition void() {
entry:
%0 = alloca f64
store 0, ptr %0
%1 = alloca f64
store 0.1, ptr %1
br label for.cond
for.body:
%2 = load f64, ptr %0
%3 = load f64, ptr %1
%4 = fadd f64 %2, %3
store f64 %4, ptr %0
br label for.iter
for.cond:
%5 = load f64, ptr %1
%6 = fcmp olt f64 %5, 0.95
br i8 %6, label for.body, label for.end
for.iter:
%7 = load f64, ptr %1
%8 = fadd f64 %7, 0.1
store f64 %8, ptr %1
br label for.cond
for.end:
%9 = load f64, ptr %0
%10 = fcmp ogt f64 %9, 4.49
%11 = load f64, ptr %0
%12 = fcmp olt f64 %11, 4.51
%13 = and i8 %10, %12
%14 = icmp ne i8 %13, 0
call i8 %14, @Assert
br label exit
exit:
ret 
}


define external @main i64() {
entry:
%0 = alloca i64
call ptr @TestForLoopInt
call ptr @TestForLoopManualIncrement
call ptr @TestForLoopMultipleExpressions
call ptr @TestNestedForLoops
call ptr @TestNestedForLoopsReset
call ptr @TestForLoopWithBreak
call ptr @TestForLoopWithContinue
call ptr @TestForLoopEmptyBody
call ptr @TestForLoopNeverExecutes
call ptr @TestForLoopFloatCondition
store 0, ptr %0
br label exit
return:
br label exit
exit:
%1 = load i64, ptr %0
ret i64 %1
}

