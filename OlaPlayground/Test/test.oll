Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @GlobalArray1 ptr [1,1,1,]


define internal @GlobalArray2 ptr [1,2,3,0,0,]


define internal @GlobalArray3 ptr [10,20,30,]


define internal @GlobalFloatArray ptr [1.5,2.5,3.5,]


define internal @GlobalBoolArray ptr [1,0,1,0,]


define internal @TestGlobalArrays void() {
entry:
call i8 1, @Assert
%0 = ptr add ptr @GlobalArray1, 0
%1 = load i64, ptr %0
%2 = icmp eq i64 %1, 1
call i8 %2, @Assert
%3 = ptr add ptr @GlobalArray1, 8
%4 = load i64, ptr %3
%5 = icmp eq i64 %4, 1
call i8 %5, @Assert
%6 = ptr add ptr @GlobalArray1, 16
%7 = load i64, ptr %6
%8 = icmp eq i64 %7, 1
call i8 %8, @Assert
call i8 1, @Assert
%9 = ptr add ptr @GlobalArray2, 0
%10 = load i64, ptr %9
%11 = icmp eq i64 %10, 1
call i8 %11, @Assert
%12 = ptr add ptr @GlobalArray2, 8
%13 = load i64, ptr %12
%14 = icmp eq i64 %13, 2
call i8 %14, @Assert
%15 = ptr add ptr @GlobalArray2, 16
%16 = load i64, ptr %15
%17 = icmp eq i64 %16, 3
call i8 %17, @Assert
%18 = ptr add ptr @GlobalArray2, 24
%19 = load i64, ptr %18
%20 = icmp eq i64 %19, 0
call i8 %20, @Assert
%21 = ptr add ptr @GlobalArray2, 32
%22 = load i64, ptr %21
%23 = icmp eq i64 %22, 0
call i8 %23, @Assert
%24 = ptr add ptr @GlobalArray3, 0
%25 = load i64, ptr %24
%26 = icmp eq i64 %25, 10
call i8 %26, @Assert
%27 = ptr add ptr @GlobalArray3, 8
%28 = load i64, ptr %27
%29 = icmp eq i64 %28, 20
call i8 %29, @Assert
%30 = ptr add ptr @GlobalArray3, 16
%31 = load i64, ptr %30
%32 = icmp eq i64 %31, 30
call i8 %32, @Assert
br label exit
exit:
ret 
}


define internal @TestLocalArrays void() {
entry:
%0 = alloca i64[10]
%1 = ptr add ptr %0, 0
store 1, ptr %1
%2 = ptr add ptr %0, 8
store 2, ptr %2
%3 = ptr add ptr %0, 16
store 0, ptr %3
%4 = ptr add ptr %0, 24
store 0, ptr %4
%5 = ptr add ptr %0, 32
store 0, ptr %5
%6 = ptr add ptr %0, 40
store 0, ptr %6
%7 = ptr add ptr %0, 48
store 0, ptr %7
%8 = ptr add ptr %0, 56
store 0, ptr %8
%9 = ptr add ptr %0, 64
store 0, ptr %9
%10 = ptr add ptr %0, 72
store 0, ptr %10
call i8 1, @Assert
%11 = load i64, ptr %1
%12 = icmp eq i64 %11, 1
call i8 %12, @Assert
%13 = load i64, ptr %2
%14 = icmp eq i64 %13, 2
call i8 %14, @Assert
%15 = load i64, ptr %3
%16 = icmp eq i64 %15, 0
call i8 %16, @Assert
%17 = load i64, ptr %7
%18 = icmp eq i64 %17, 0
call i8 %18, @Assert
%19 = alloca i64[3]
%20 = ptr add ptr %19, 0
store -5, ptr %20
%21 = ptr add ptr %19, 8
store 0, ptr %21
%22 = ptr add ptr %19, 16
store 5, ptr %22
%23 = load i64, ptr %20
%24 = icmp eq i64 %23, -5
call i8 %24, @Assert
%25 = load i64, ptr %21
%26 = icmp eq i64 %25, 0
call i8 %26, @Assert
%27 = load i64, ptr %22
%28 = icmp eq i64 %27, 5
call i8 %28, @Assert
call i8 1, @Assert
br label exit
exit:
ret 
}


define internal @TestFloatArrays void() {
entry:
%0 = ptr add ptr @GlobalFloatArray, 0
%1 = load f64, ptr %0
%2 = fcmp ogt f64 %1, 1.4999
%3 = load f64, ptr %0
%4 = fcmp olt f64 %3, 1.5001
%5 = and i8 %2, %4
%6 = icmp ne i8 %5, 0
call i8 %6, @Assert
%7 = ptr add ptr @GlobalFloatArray, 8
%8 = load f64, ptr %7
%9 = fcmp ogt f64 %8, 2.4999
%10 = load f64, ptr %7
%11 = fcmp olt f64 %10, 2.5001
%12 = and i8 %9, %11
%13 = icmp ne i8 %12, 0
call i8 %13, @Assert
%14 = ptr add ptr @GlobalFloatArray, 16
%15 = load f64, ptr %14
%16 = fcmp ogt f64 %15, 3.4999
%17 = load f64, ptr %14
%18 = fcmp olt f64 %17, 3.5001
%19 = and i8 %16, %18
%20 = icmp ne i8 %19, 0
call i8 %20, @Assert
%21 = alloca f64[4]
%22 = ptr add ptr %21, 0
store 0.5, ptr %22
%23 = ptr add ptr %21, 8
store 1, ptr %23
%24 = ptr add ptr %21, 16
store 1.5, ptr %24
%25 = ptr add ptr %21, 24
store 2, ptr %25
%26 = load f64, ptr %22
%27 = fcmp ogt f64 %26, 0.4999
%28 = load f64, ptr %22
%29 = fcmp olt f64 %28, 0.5001
%30 = and i8 %27, %29
%31 = icmp ne i8 %30, 0
call i8 %31, @Assert
%32 = load f64, ptr %25
%33 = fcmp ogt f64 %32, 1.9999
%34 = load f64, ptr %25
%35 = fcmp olt f64 %34, 2.0001
%36 = and i8 %33, %35
%37 = icmp ne i8 %36, 0
call i8 %37, @Assert
%38 = load f64, ptr %22
%39 = load f64, ptr %23
%40 = fadd f64 %38, %39
%41 = load f64, ptr %24
%42 = fadd f64 %40, %41
%43 = load f64, ptr %25
%44 = fadd f64 %42, %43
%45 = fcmp ogt f64 %44, 4.9999
%46 = fcmp olt f64 %44, 5.0001
%47 = and i8 %45, %46
%48 = icmp ne i8 %47, 0
call i8 %48, @Assert
br label exit
exit:
ret 
}


define internal @TestBoolArrays void() {
entry:
%0 = ptr add ptr @GlobalBoolArray, 0
%1 = load i8, ptr %0
%2 = icmp eq i8 %1, 1
call i8 %2, @Assert
%3 = ptr add ptr @GlobalBoolArray, 1
%4 = load i8, ptr %3
%5 = icmp eq i8 %4, 0
call i8 %5, @Assert
%6 = ptr add ptr @GlobalBoolArray, 2
%7 = load i8, ptr %6
%8 = icmp eq i8 %7, 1
call i8 %8, @Assert
%9 = ptr add ptr @GlobalBoolArray, 3
%10 = load i8, ptr %9
%11 = icmp eq i8 %10, 0
call i8 %11, @Assert
%12 = alloca i8[3]
%13 = ptr add ptr %12, 0
store 1, ptr %13
%14 = ptr add ptr %12, 1
store 1, ptr %14
%15 = ptr add ptr %12, 2
store 0, ptr %15
%16 = load i8, ptr %13
%17 = icmp eq i8 %16, 1
call i8 %17, @Assert
%18 = load i8, ptr %14
%19 = icmp eq i8 %18, 1
call i8 %19, @Assert
%20 = load i8, ptr %15
%21 = icmp eq i8 %20, 0
call i8 %21, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayModification void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 1, ptr %1
%2 = ptr add ptr %0, 8
store 2, ptr %2
%3 = ptr add ptr %0, 16
store 3, ptr %3
%4 = ptr add ptr %0, 24
store 4, ptr %4
%5 = ptr add ptr %0, 32
store 5, ptr %5
store 10, ptr %1
%6 = load i64, ptr %1
%7 = icmp eq i64 %6, 10
call i8 %7, @Assert
store 50, ptr %5
%8 = load i64, ptr %5
%9 = icmp eq i64 %8, 50
call i8 %9, @Assert
%10 = load i64, ptr %1
%11 = load i64, ptr %5
%12 = add i64 %10, %11
store i64 %12, ptr %3
%13 = load i64, ptr %3
%14 = icmp eq i64 %13, 60
call i8 %14, @Assert
%15 = load i64, ptr %2
%16 = add i64 %15, %15
store i64 %16, ptr %2
%17 = load i64, ptr %2
%18 = icmp eq i64 %17, 4
call i8 %18, @Assert
%19 = load i64, ptr %4
%20 = alloca ptr
store i64 %19, ptr %20
%21 = add i64 %19, 1
store i64 %21, ptr %4
%22 = load i64, ptr %4
%23 = icmp eq i64 %22, 5
call i8 %23, @Assert
%24 = load i64, ptr %4
%25 = add i64 %24, 1
store i64 %25, ptr %4
%26 = load i64, ptr %4
%27 = icmp eq i64 %26, 6
call i8 %27, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayExpressions void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 10, ptr %1
%2 = ptr add ptr %0, 8
store 20, ptr %2
%3 = ptr add ptr %0, 16
store 30, ptr %3
%4 = ptr add ptr %0, 24
store 40, ptr %4
%5 = ptr add ptr %0, 32
store 50, ptr %5
%6 = load i64, ptr %1
%7 = load i64, ptr %2
%8 = add i64 %6, %7
%9 = load i64, ptr %3
%10 = add i64 %8, %9
%11 = load i64, ptr %4
%12 = add i64 %10, %11
%13 = load i64, ptr %5
%14 = add i64 %12, %13
%15 = icmp eq i64 %14, 150
call i8 %15, @Assert
%16 = load i64, ptr %1
%17 = load i64, ptr %2
%18 = smul i64 %16, %17
%19 = icmp eq i64 %18, 200
call i8 %19, @Assert
%20 = load i64, ptr %5
%21 = load i64, ptr %1
%22 = sub i64 %20, %21
%23 = icmp eq i64 %22, 40
call i8 %23, @Assert
%24 = load i64, ptr %5
%25 = load i64, ptr %1
%26 = icmp sgt i64 %24, %25
%27 = icmp eq i8 %26, 1
call i8 %27, @Assert
%28 = load i64, ptr %1
%29 = load i64, ptr %2
%30 = add i64 %28, %29
%31 = load i64, ptr %3
%32 = add i64 %30, %31
%33 = sdiv i64 %32, 3
%34 = icmp eq i64 %33, 20
call i8 %34, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayVariableIndex void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 100, ptr %1
%2 = ptr add ptr %0, 8
store 200, ptr %2
%3 = ptr add ptr %0, 16
store 300, ptr %3
%4 = ptr add ptr %0, 24
store 400, ptr %4
%5 = ptr add ptr %0, 32
store 500, ptr %5
%6 = gep ptr %0, 0, 0
%7 = load i64, ptr %6
%8 = icmp eq i64 %7, 100
call i8 %8, @Assert
%9 = gep ptr %0, 0, 2
%10 = load i64, ptr %9
%11 = icmp eq i64 %10, 300
call i8 %11, @Assert
%12 = gep ptr %0, 0, 4
%13 = load i64, ptr %12
%14 = icmp eq i64 %13, 500
call i8 %14, @Assert
%15 = load i64, ptr %9
%16 = icmp eq i64 %15, 300
call i8 %16, @Assert
%17 = load i64, ptr %9
%18 = icmp eq i64 %17, 300
call i8 %18, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayInLoops void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 1, ptr %1
%2 = ptr add ptr %0, 8
store 2, ptr %2
%3 = ptr add ptr %0, 16
store 3, ptr %3
%4 = ptr add ptr %0, 24
store 4, ptr %4
%5 = ptr add ptr %0, 32
store 5, ptr %5
%6 = alloca ptr
br label for.cond
for.body:
%7 = gep ptr %0, 0, %8
%9 = load i64, ptr %7
%10 = add i64 %11, %9
br label for.iter
for.cond:
%8 = phi i64 [ 0, entry ], [ %12, for.iter ]
%11 = phi i64 [ 0, entry ], [ %10, for.iter ]
%13 = icmp slt i64 %8, 5
br i8 %13, label for.body, label for.end
for.iter:
store i64 %8, ptr %6
%12 = add i64 %8, 1
br label for.cond
for.end:
%14 = icmp eq i64 %11, 15
call i8 %14, @Assert
%15 = alloca ptr
br label for.cond1
for.body1:
%16 = gep ptr %0, 0, %17
%18 = load i64, ptr %16
%19 = add i64 %18, %18
store i64 %19, ptr %16
br label for.iter1
for.cond1:
%17 = phi i64 [ 0, for.end ], [ %20, for.iter1 ]
%21 = icmp slt i64 %17, 5
br i8 %21, label for.body1, label for.end1
for.iter1:
store i64 %17, ptr %15
%20 = add i64 %17, 1
br label for.cond1
for.end1:
%22 = ptr add ptr %0, 0
%23 = load i64, ptr %22
%24 = icmp eq i64 %23, 2
call i8 %24, @Assert
%25 = ptr add ptr %0, 8
%26 = load i64, ptr %25
%27 = icmp eq i64 %26, 4
call i8 %27, @Assert
%28 = ptr add ptr %0, 16
%29 = load i64, ptr %28
%30 = icmp eq i64 %29, 6
call i8 %30, @Assert
%31 = ptr add ptr %0, 24
%32 = load i64, ptr %31
%33 = icmp eq i64 %32, 8
call i8 %33, @Assert
%34 = ptr add ptr %0, 32
%35 = load i64, ptr %34
%36 = icmp eq i64 %35, 10
call i8 %36, @Assert
%37 = alloca i64
%38 = load ptr, ptr %22
store ptr %38, ptr %37
%39 = alloca ptr
br label for.cond2
for.body2:
%40 = gep ptr %0, 0, %41
%42 = load i64, ptr %40
%43 = load i64, ptr %37
%44 = icmp sgt i64 %42, %43
br i8 %44, label if.then, label for.iter2
for.cond2:
%41 = phi i64 [ 1, for.end1 ], [ %45, for.iter2 ]
%46 = icmp slt i64 %41, 5
br i8 %46, label for.body2, label exit
for.iter2:
store i64 %41, ptr %39
%45 = add i64 %41, 1
br label for.cond2
if.then:
%47 = gep ptr %0, 0, %41
%48 = load i64, ptr %47
store i64 %48, ptr %37
br label for.iter2
exit:
ret 
}


define internal @TestArrayWhileLoop void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 5, ptr %1
%2 = ptr add ptr %0, 8
store 4, ptr %2
%3 = ptr add ptr %0, 16
store 3, ptr %3
%4 = ptr add ptr %0, 24
store 2, ptr %4
%5 = ptr add ptr %0, 32
store 1, ptr %5
%6 = alloca ptr
br label while.cond
while.cond:
%7 = phi i64 [ 0, entry ], [ %8, while.body ]
%9 = phi i64 [ 0, entry ], [ %10, while.body ]
%11 = icmp slt i64 %9, 5
br i8 %11, label while.body, label while.end
while.body:
%12 = gep ptr %0, 0, %9
%13 = load i64, ptr %12
%8 = add i64 %7, %13
store i64 %9, ptr %6
%10 = add i64 %9, 1
br label while.cond
while.end:
%14 = icmp eq i64 %7, 15
call i8 %14, @Assert
%15 = alloca ptr
br label while.cond1
while.cond1:
%16 = phi i64 [ 0, while.end ], [ %17, if.end ]
%18 = icmp slt i64 %16, 5
br i8 %18, label while.body1, label while.end1
while.body1:
%19 = gep ptr %0, 0, %16
%20 = load i64, ptr %19
%21 = srem i64 %20, 2
%22 = icmp eq i64 %21, 0
br i8 %22, label while.end1, label if.end
while.end1:
%23 = gep ptr %0, 0, %16
%24 = load i64, ptr %23
%25 = icmp eq i64 %24, 4
call i8 %25, @Assert
br label exit
if.end:
store i64 %16, ptr %15
%17 = add i64 %16, 1
br label while.cond1
exit:
ret 
}


define internal @TestArrayNegativeValues void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store -10, ptr %1
%2 = ptr add ptr %0, 8
store -5, ptr %2
%3 = ptr add ptr %0, 16
store 0, ptr %3
%4 = ptr add ptr %0, 24
store 5, ptr %4
%5 = ptr add ptr %0, 32
store 10, ptr %5
%6 = load i64, ptr %1
%7 = icmp eq i64 %6, -10
call i8 %7, @Assert
%8 = load i64, ptr %2
%9 = icmp eq i64 %8, -5
call i8 %9, @Assert
%10 = load i64, ptr %3
%11 = icmp eq i64 %10, 0
call i8 %11, @Assert
%12 = load i64, ptr %4
%13 = icmp eq i64 %12, 5
call i8 %13, @Assert
%14 = load i64, ptr %5
%15 = icmp eq i64 %14, 10
call i8 %15, @Assert
%16 = load i64, ptr %1
%17 = load i64, ptr %2
%18 = add i64 %16, %17
%19 = load i64, ptr %3
%20 = add i64 %18, %19
%21 = load i64, ptr %4
%22 = add i64 %20, %21
%23 = load i64, ptr %5
%24 = add i64 %22, %23
%25 = icmp eq i64 %24, 0
call i8 %25, @Assert
%26 = load i64, ptr %5
%27 = neg i64 %26
store i64 %27, ptr %1
%28 = load i64, ptr %1
%29 = icmp eq i64 %28, -10
call i8 %29, @Assert
br label exit
exit:
ret 
}


define internal @TestAutoArray void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 10, ptr %1
%2 = ptr add ptr %0, 8
store 20, ptr %2
%3 = ptr add ptr %0, 16
store 30, ptr %3
%4 = ptr add ptr %0, 24
store 40, ptr %4
%5 = ptr add ptr %0, 32
store 50, ptr %5
call i8 1, @Assert
%6 = load i64, ptr %1
%7 = icmp eq i64 %6, 10
call i8 %7, @Assert
%8 = load i64, ptr %5
%9 = icmp eq i64 %8, 50
call i8 %9, @Assert
%10 = alloca ptr
br label for.cond
for.body:
%11 = gep ptr %0, 0, %12
%13 = load i64, ptr %11
%14 = add i64 %15, %13
br label for.iter
for.cond:
%12 = phi i64 [ 0, entry ], [ %16, for.iter ]
%15 = phi i64 [ 0, entry ], [ %14, for.iter ]
%17 = icmp slt i64 %12, 5
br i8 %17, label for.body, label for.end
for.iter:
store i64 %12, ptr %10
%16 = add i64 %12, 1
br label for.cond
for.end:
%18 = icmp eq i64 %15, 150
call i8 %18, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayBoundary void() {
entry:
%0 = alloca i64[1]
%1 = ptr add ptr %0, 0
store 42, ptr %1
%2 = load i64, ptr %1
%3 = icmp eq i64 %2, 42
call i8 %3, @Assert
call i8 1, @Assert
%4 = alloca i64[10]
%5 = ptr add ptr %4, 0
store 1, ptr %5
%6 = ptr add ptr %4, 8
store 2, ptr %6
%7 = ptr add ptr %4, 16
store 3, ptr %7
%8 = ptr add ptr %4, 24
store 4, ptr %8
%9 = ptr add ptr %4, 32
store 5, ptr %9
%10 = ptr add ptr %4, 40
store 6, ptr %10
%11 = ptr add ptr %4, 48
store 7, ptr %11
%12 = ptr add ptr %4, 56
store 8, ptr %12
%13 = ptr add ptr %4, 64
store 9, ptr %13
%14 = ptr add ptr %4, 72
store 10, ptr %14
%15 = load i64, ptr %5
%16 = icmp eq i64 %15, 1
call i8 %16, @Assert
%17 = load i64, ptr %14
%18 = icmp eq i64 %17, 10
call i8 %18, @Assert
%19 = alloca ptr
br label for.cond
for.body:
%20 = gep ptr %4, 0, %21
%22 = load i64, ptr %20
%23 = add i64 %24, %22
br label for.iter
for.cond:
%21 = phi i64 [ 0, entry ], [ %25, for.iter ]
%24 = phi i64 [ 0, entry ], [ %23, for.iter ]
%26 = icmp slt i64 %21, 10
br i8 %26, label for.body, label for.end
for.iter:
store i64 %21, ptr %19
%25 = add i64 %21, 1
br label for.cond
for.end:
%27 = icmp eq i64 %24, 55
call i8 %27, @Assert
br label exit
exit:
ret 
}


define internal @TestArraySwap void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 1, ptr %1
%2 = ptr add ptr %0, 8
store 2, ptr %2
%3 = ptr add ptr %0, 16
store 3, ptr %3
%4 = ptr add ptr %0, 24
store 4, ptr %4
%5 = ptr add ptr %0, 32
store 5, ptr %5
%6 = alloca i64
%7 = load ptr, ptr %1
store ptr %7, ptr %6
%8 = load ptr, ptr %5
store ptr %8, ptr %1
%9 = load i64, ptr %6
store i64 %9, ptr %5
%10 = load i64, ptr %1
%11 = icmp eq i64 %10, 5
call i8 %11, @Assert
%12 = load i64, ptr %5
%13 = icmp eq i64 %12, 1
call i8 %13, @Assert
%14 = load i64, ptr %2
%15 = icmp eq i64 %14, 2
call i8 %15, @Assert
%16 = load i64, ptr %3
%17 = icmp eq i64 %16, 3
call i8 %17, @Assert
%18 = load i64, ptr %4
%19 = icmp eq i64 %18, 4
call i8 %19, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayTernary void() {
entry:
%0 = alloca i64[3]
%1 = ptr add ptr %0, 0
store 10, ptr %1
%2 = ptr add ptr %0, 8
store 20, ptr %2
%3 = ptr add ptr %0, 16
store 30, ptr %3
%4 = load i64, ptr %1
%5 = load i64, ptr %2
%6 = icmp sgt i64 %4, %5
%7 = load i64, ptr %1
%8 = load i64, ptr %2
%9 = select i8 %6, i64 %7, i64 %8
%10 = icmp eq i64 %9, 20
call i8 %10, @Assert
%11 = load i64, ptr %3
%12 = icmp sgt i64 %9, %11
%13 = load i64, ptr %3
%14 = select i8 %12, i64 %9, i64 %13
%15 = icmp eq i64 %14, 30
call i8 %15, @Assert
%16 = gep ptr %0, 0, 0
%17 = load i64, ptr %16
%18 = icmp eq i64 %17, 10
call i8 %18, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayAssignment void() {
entry:
%0 = alloca i64[3]
%1 = ptr add ptr %0, 0
store 1, ptr %1
%2 = ptr add ptr %0, 8
store 2, ptr %2
%3 = ptr add ptr %0, 16
store 3, ptr %3
%4 = alloca i64[3]
%5 = alloca ptr
br label for.cond
for.body:
%6 = gep ptr %4, 0, %7
%8 = gep ptr %0, 0, %7
%9 = load i64, ptr %8
store i64 %9, ptr %6
br label for.iter
for.cond:
%7 = phi i64 [ 0, entry ], [ %10, for.iter ]
%11 = icmp slt i64 %7, 3
br i8 %11, label for.body, label for.end
for.iter:
store i64 %7, ptr %5
%10 = add i64 %7, 1
br label for.cond
for.end:
%12 = ptr add ptr %4, 0
%13 = load i64, ptr %12
%14 = icmp eq i64 %13, 1
call i8 %14, @Assert
%15 = ptr add ptr %4, 8
%16 = load i64, ptr %15
%17 = icmp eq i64 %16, 2
call i8 %17, @Assert
%18 = ptr add ptr %4, 16
%19 = load i64, ptr %18
%20 = icmp eq i64 %19, 3
call i8 %20, @Assert
%21 = ptr add ptr %0, 0
store 100, ptr %21
%22 = load i64, ptr %21
%23 = icmp eq i64 %22, 100
call i8 %23, @Assert
%24 = load i64, ptr %12
%25 = icmp eq i64 %24, 1
call i8 %25, @Assert
br label exit
exit:
ret 
}


define internal @TestArrayAccumulation void() {
entry:
%0 = alloca i64[5]
%1 = ptr add ptr %0, 0
store 0, ptr %1
%2 = ptr add ptr %0, 8
store 0, ptr %2
%3 = ptr add ptr %0, 16
store 0, ptr %3
%4 = ptr add ptr %0, 24
store 0, ptr %4
%5 = ptr add ptr %0, 32
store 0, ptr %5
%6 = alloca ptr
%7 = alloca ptr
br label for.cond
for.body:
%8 = srem i64 %9, 5
%10 = gep ptr %0, 0, %8
%11 = load i64, ptr %10
store i64 %11, ptr %7
%12 = add i64 %11, 1
store i64 %12, ptr %10
br label for.iter
for.cond:
%9 = phi i64 [ 0, entry ], [ %13, for.iter ]
%14 = icmp slt i64 %9, 100
br i8 %14, label for.body, label for.end
for.iter:
store i64 %9, ptr %6
%13 = add i64 %9, 1
br label for.cond
for.end:
%15 = ptr add ptr %0, 0
%16 = load i64, ptr %15
%17 = icmp eq i64 %16, 20
call i8 %17, @Assert
%18 = ptr add ptr %0, 8
%19 = load i64, ptr %18
%20 = icmp eq i64 %19, 20
call i8 %20, @Assert
%21 = ptr add ptr %0, 16
%22 = load i64, ptr %21
%23 = icmp eq i64 %22, 20
call i8 %23, @Assert
%24 = ptr add ptr %0, 24
%25 = load i64, ptr %24
%26 = icmp eq i64 %25, 20
call i8 %26, @Assert
%27 = ptr add ptr %0, 32
%28 = load i64, ptr %27
%29 = icmp eq i64 %28, 20
call i8 %29, @Assert
br label exit
exit:
ret 
}


define external @main i64() {
entry:
call ptr @TestGlobalArrays
call ptr @TestLocalArrays
call ptr @TestFloatArrays
call ptr @TestBoolArrays
call ptr @TestArrayModification
call ptr @TestArrayExpressions
call ptr @TestArrayVariableIndex
call ptr @TestArrayInLoops
call ptr @TestArrayWhileLoop
br label entry.inlined
entry.split:
call ptr @TestArrayNegativeValues
call ptr @TestAutoArray
call ptr @TestArrayBoundary
call ptr @TestArraySwap
call ptr @TestArrayTernary
call ptr @TestArrayAssignment
call ptr @TestArrayAccumulation
br label exit
entry.inlined:
call i8 1, @Assert
call i8 1, @Assert
call i8 1, @Assert
call i8 1, @Assert
call i8 1, @Assert
call i8 1, @Assert
br label entry.split
exit:
ret i64 0
}

