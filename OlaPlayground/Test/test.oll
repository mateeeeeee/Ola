Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @GlobalIntX ptr 2


define internal @TestSwitchBasic void() {
entry:
br label switch.header
switch.header:
switch i64 1, switch.default, switch.case1, switch.case2
switch.default:
br label exit
switch.end:
%0 = phi i64 [ 10, switch.case1 ], [ 20, switch.case2 ]
%1 = icmp eq i64 %0, 10
call i8 %1, @Assert
br label exit
switch.case1:
br label switch.end
switch.case2:
br label switch.end
exit:
ret 
}


define internal @TestSwitchMultipleCases void() {
entry:
br label switch.header
switch.header:
switch i64 3, switch.default, switch.case2, switch.case2, switch.case4, switch.case4
switch.default:
br label exit
switch.end:
%0 = phi i64 [ 10, switch.case2 ], [ 20, switch.case4 ]
%1 = icmp eq i64 %0, 20
call i8 %1, @Assert
br label exit
switch.case1:
br label switch.case2
switch.case2:
br label switch.end
switch.case3:
br label switch.case4
switch.case4:
br label switch.end
exit:
ret 
}


define internal @TestSwitchFallthrough void() {
entry:
br label switch.header
switch.header:
switch i64 2, switch.default, switch.case1, switch.case2, switch.case3
switch.default:
br label exit
switch.end:
%0 = icmp eq i64 %1, 50
call i8 %0, @Assert
br label exit
switch.case1:
br label switch.case2
switch.case2:
%2 = phi i64 [ 0, switch.header ], [ 10, switch.case1 ]
%3 = add i64 %2, 20
br label switch.case3
switch.case3:
%4 = phi i64 [ 0, switch.header ], [ %3, switch.case2 ]
%1 = add i64 %4, 30
br label switch.end
exit:
ret 
}


define internal @TestSwitchWithBreak void() {
entry:
br label switch.header
switch.header:
switch i64 2, switch.default, switch.case1, switch.case2, switch.case3
switch.default:
br label exit
switch.end:
%0 = phi i64 [ 30, switch.case3 ], [ 10, switch.case1 ], [ 20, switch.case2 ]
%1 = icmp eq i64 %0, 20
call i8 %1, @Assert
br label exit
switch.case1:
br label switch.end
switch.case2:
br label switch.end
switch.case3:
br label switch.end
exit:
ret 
}


define internal @TestSwitchGlobalVariable void() {
entry:
br label switch.header
switch.header:
%0 = load i64, ptr @GlobalIntX
switch i64 %0, switch.default, switch.case1, switch.case2, switch.case3
switch.default:
br label exit
switch.end:
%1 = phi i64 [ 1, switch.case1 ], [ 2, switch.case2 ], [ 3, switch.case3 ]
%2 = icmp eq i64 %1, 2
call i8 %2, @Assert
br label exit
switch.case1:
br label switch.end
switch.case2:
br label switch.end
switch.case3:
br label switch.end
exit:
ret 
}


define internal @TestSwitchNoMatch void() {
entry:
br label switch.header
switch.header:
switch i64 5, switch.default, switch.case1, switch.case2, switch.case3
switch.default:
br label exit
switch.end:
%0 = phi i64 [ 1, switch.case1 ], [ 2, switch.case2 ], [ 3, switch.case3 ]
%1 = icmp eq i64 %0, -1
call i8 %1, @Assert
br label exit
switch.case1:
br label switch.end
switch.case2:
br label switch.end
switch.case3:
br label switch.end
exit:
ret 
}


define external @main i64() {
entry:
call ptr @TestSwitchBasic
call ptr @TestSwitchMultipleCases
call ptr @TestSwitchFallthrough
call ptr @TestSwitchWithBreak
br label entry.split
entry.split:
call ptr @TestSwitchGlobalVariable
br label entry.split.split
entry.split.split:
call ptr @TestSwitchNoMatch
br label exit
exit:
ret i64 0
}

