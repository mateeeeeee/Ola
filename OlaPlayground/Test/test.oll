Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @TestForLoopInt void() {
entry:
%0 = alloca ptr
store 1, ptr %0
store 2, ptr %0
store 3, ptr %0
store 4, ptr %0
store 5, ptr %0
br label for.end
for.end:
call i8 1, @Assert
br label exit
exit:
ret 
}


define internal @TestForLoopManualIncrement void() {
entry:
br label for.end
for.end:
call i8 1, @Assert
br label exit
exit:
ret 
}


define internal @TestForLoopMultipleExpressions void() {
entry:
%0 = alloca ptr
%1 = alloca ptr
store 1, ptr %0
store 5, ptr %1
store 2, ptr %0
store 4, ptr %1
store 3, ptr %0
store 3, ptr %1
br label for.end
for.end:
call i8 1, @Assert
br label exit
exit:
ret 
}


define internal @TestNestedForLoops void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
%2 = alloca i64
store 0, ptr %2
br label for.cond
for.body:
br label for.cond1
for.cond:
%3 = load i64, ptr %0
%4 = icmp slt i64 %3, 3
br i8 %4, label for.body, label for.end
for.iter:
%5 = load i64, ptr %0
%6 = alloca ptr
store i64 %5, ptr %6
%7 = add i64 %5, 1
store i64 %7, ptr %0
br label for.cond
for.end:
%8 = load i64, ptr %0
%9 = icmp eq i64 %8, 3
call i8 %9, @Assert
%10 = load i64, ptr %1
%11 = icmp eq i64 %10, 2
call i8 %11, @Assert
br label exit
for.body1:
%12 = load i64, ptr %2
%13 = add i64 %12, 1
store i64 %13, ptr %2
br label for.iter1
for.cond1:
%14 = load i64, ptr %1
%15 = icmp slt i64 %14, 2
br i8 %15, label for.body1, label for.end1
for.iter1:
%16 = load i64, ptr %1
%17 = alloca ptr
store i64 %16, ptr %17
%18 = add i64 %16, 1
store i64 %18, ptr %1
br label for.cond1
for.end1:
br label for.iter
exit:
ret 
}


define internal @TestNestedForLoopsReset void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
br label for.cond
for.body:
%2 = alloca i64
store 0, ptr %2
br label for.cond1
for.cond:
%3 = load i64, ptr %0
%4 = icmp slt i64 %3, 3
br i8 %4, label for.body, label for.end
for.iter:
%5 = load i64, ptr %0
%6 = alloca ptr
store i64 %5, ptr %6
%7 = add i64 %5, 1
store i64 %7, ptr %0
br label for.cond
for.end:
%8 = load i64, ptr %0
%9 = icmp eq i64 %8, 3
call i8 %9, @Assert
%10 = load i64, ptr %1
%11 = icmp eq i64 %10, 6
call i8 %11, @Assert
br label exit
for.body1:
%12 = load i64, ptr %1
%13 = alloca ptr
store i64 %12, ptr %13
%14 = add i64 %12, 1
store i64 %14, ptr %1
br label for.iter1
for.cond1:
%15 = load i64, ptr %2
%16 = icmp slt i64 %15, 2
br i8 %16, label for.body1, label for.end1
for.iter1:
%17 = load i64, ptr %2
%18 = alloca ptr
store i64 %17, ptr %18
%19 = add i64 %17, 1
store i64 %19, ptr %2
br label for.cond1
for.end1:
br label for.iter
exit:
ret 
}


define internal @TestForLoopWithBreak void() {
entry:
%0 = alloca ptr
br label for.cond
for.body:
%1 = add i64 %2, %3
%4 = icmp eq i64 %3, 3
br i8 %4, label if.then, label for.iter
for.cond:
%3 = phi i64 [ 1, entry ], [ %5, for.iter ]
%2 = phi i64 [ 0, entry ], [ %1, for.iter ]
%6 = icmp sle i64 %3, 5
br i8 %6, label for.body, label for.end
for.iter:
store i64 %3, ptr %0
%5 = add i64 %3, 1
br label for.cond
for.end:
%7 = phi i64 [ %2, for.cond ], [ %1, if.then ]
%8 = icmp eq i64 %7, 6
call i8 %8, @Assert
br label exit
if.then:
br label for.end
exit:
ret 
}


define internal @TestForLoopWithContinue void() {
entry:
%0 = alloca ptr
store 1, ptr %0
store 2, ptr %0
store 3, ptr %0
store 4, ptr %0
store 5, ptr %0
br label for.end
for.end:
call i8 0, @Assert
br label exit
exit:
ret 
}


define internal @TestForLoopEmptyBody void() {
entry:
%0 = alloca ptr
store 0, ptr %0
store 1, ptr %0
store 2, ptr %0
store 3, ptr %0
store 4, ptr %0
br label for.end
for.end:
call i8 1, @Assert
call i8 1, @Assert
br label exit
exit:
ret 
}


define external @main i64() {
entry:
call ptr @TestForLoopInt
call ptr @TestForLoopManualIncrement
call ptr @TestForLoopMultipleExpressions
call ptr @TestNestedForLoops
call ptr @TestNestedForLoopsReset
call ptr @TestForLoopWithBreak
call ptr @TestForLoopWithContinue
call ptr @TestForLoopEmptyBody
br label exit
exit:
ret i64 0
}

