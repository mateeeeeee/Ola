Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @Add__I__I i64(i64 %a,i64 %b) {
entry:
%0 = alloca i64
store i64 %a, ptr %0
%1 = alloca i64
store i64 %b, ptr %1
%2 = alloca i64
%3 = load i64, ptr %0
%4 = load i64, ptr %1
%5 = add i64 %3, %4
store i64 %5, ptr %2
br label exit
return:
br label exit
exit:
%6 = load i64, ptr %2
ret i64 %6
}


define internal @AddThreeNumbers__I__I__I i64(i64 %a,i64 %b,i64 %c) {
entry:
%0 = alloca i64
store i64 %a, ptr %0
%1 = alloca i64
store i64 %b, ptr %1
%2 = alloca i64
store i64 %c, ptr %2
%3 = alloca i64
%4 = load i64, ptr %0
%5 = load i64, ptr %1
%6 = add i64 %4, %5
%7 = load i64, ptr %2
%8 = add i64 %6, %7
store i64 %8, ptr %3
br label exit
return:
br label exit
exit:
%9 = load i64, ptr %3
ret i64 %9
}


define internal @AddFourNumbers__I__I__I__I i64(i64 %a,i64 %b,i64 %c,i64 %d) {
entry:
%0 = alloca i64
store i64 %a, ptr %0
%1 = alloca i64
store i64 %b, ptr %1
%2 = alloca i64
store i64 %c, ptr %2
%3 = alloca i64
store i64 %d, ptr %3
%4 = alloca i64
%5 = load i64, ptr %0
%6 = load i64, ptr %1
%7 = add i64 %5, %6
%8 = load i64, ptr %2
%9 = add i64 %7, %8
%10 = load i64, ptr %3
%11 = add i64 %9, %10
store i64 %11, ptr %4
br label exit
return:
br label exit
exit:
%12 = load i64, ptr %4
ret i64 %12
}


define internal @AddSixNumbers__I__I__I__I__I__I i64(i64 %a,i64 %b,i64 %c,i64 %d,i64 %e,i64 %f) {
entry:
%0 = alloca i64
store i64 %a, ptr %0
%1 = alloca i64
store i64 %b, ptr %1
%2 = alloca i64
store i64 %c, ptr %2
%3 = alloca i64
store i64 %d, ptr %3
%4 = alloca i64
store i64 %e, ptr %4
%5 = alloca i64
store i64 %f, ptr %5
%6 = alloca i64
%7 = load i64, ptr %0
%8 = load i64, ptr %1
%9 = add i64 %7, %8
%10 = load i64, ptr %2
%11 = add i64 %9, %10
%12 = load i64, ptr %3
%13 = add i64 %11, %12
%14 = load i64, ptr %4
%15 = add i64 %13, %14
%16 = load i64, ptr %5
%17 = add i64 %15, %16
store i64 %17, ptr %6
br label exit
return:
br label exit
exit:
%18 = load i64, ptr %6
ret i64 %18
}


define internal @AlternatingSum__I__I__I__I__I__I i64(i64 %a,i64 %b,i64 %c,i64 %d,i64 %e,i64 %f) {
entry:
%0 = alloca i64
store i64 %a, ptr %0
%1 = alloca i64
store i64 %b, ptr %1
%2 = alloca i64
store i64 %c, ptr %2
%3 = alloca i64
store i64 %d, ptr %3
%4 = alloca i64
store i64 %e, ptr %4
%5 = alloca i64
store i64 %f, ptr %5
%6 = alloca i64
%7 = load i64, ptr %0
%8 = load i64, ptr %1
%9 = sub i64 %7, %8
%10 = load i64, ptr %2
%11 = add i64 %9, %10
%12 = load i64, ptr %3
%13 = sub i64 %11, %12
%14 = load i64, ptr %4
%15 = add i64 %13, %14
%16 = load i64, ptr %5
%17 = sub i64 %15, %16
store i64 %17, ptr %6
br label exit
return:
br label exit
exit:
%18 = load i64, ptr %6
ret i64 %18
}


define internal @AddFloats__F__F f64(f64 %a,f64 %b) {
entry:
%0 = alloca f64
store f64 %a, ptr %0
%1 = alloca f64
store f64 %b, ptr %1
%2 = alloca f64
%3 = load f64, ptr %0
%4 = load f64, ptr %1
%5 = fadd f64 %3, %4
store f64 %5, ptr %2
br label exit
return:
br label exit
exit:
%6 = load f64, ptr %2
ret f64 %6
}


define internal @AddIntAndFloat__I__F__F f64(i64 %a,f64 %b,f64 %c) {
entry:
%0 = alloca i64
store i64 %a, ptr %0
%1 = alloca f64
store f64 %b, ptr %1
%2 = alloca f64
store f64 %c, ptr %2
%3 = alloca f64
%4 = load i64, ptr %0
%5 = s2f i64 %4
%6 = load f64, ptr %1
%7 = fadd f64 %5, %6
%8 = load f64, ptr %2
%9 = fadd f64 %7, %8
store f64 %9, ptr %3
br label exit
return:
br label exit
exit:
%10 = load f64, ptr %3
ret f64 %10
}


define internal @ConditionSum__F__F__F__F__B f64(f64 %a,f64 %b,f64 %c,f64 %d,i8 %e) {
entry:
%0 = alloca f64
store f64 %a, ptr %0
%1 = alloca f64
store f64 %b, ptr %1
%2 = alloca f64
store f64 %c, ptr %2
%3 = alloca f64
store f64 %d, ptr %3
%4 = alloca i8
store i8 %e, ptr %4
%5 = alloca f64
%6 = load i8, ptr %4
%7 = load f64, ptr %0
%8 = load f64, ptr %1
%9 = fadd f64 %7, %8
%10 = load f64, ptr %2
%11 = load f64, ptr %3
%12 = fadd f64 %10, %11
%13 = select i8 %6, f64 %9, f64 %12
store f64 %13, ptr %5
br label exit
return:
br label exit
exit:
%14 = load f64, ptr %5
ret f64 %14
}


define internal @AddBooleans__B__B__B__B i64(i8 %a,i8 %b,i8 %c,i8 %d) {
entry:
%0 = alloca i8
store i8 %a, ptr %0
%1 = alloca i8
store i8 %b, ptr %1
%2 = alloca i8
store i8 %c, ptr %2
%3 = alloca i8
store i8 %d, ptr %3
%4 = alloca i64
%5 = load i8, ptr %0
%6 = load i8, ptr %1
%7 = add i8 %5, %6
%8 = load i8, ptr %2
%9 = add i8 %7, %8
%10 = load i8, ptr %3
%11 = add i8 %9, %10
%12 = zext i8 %11
store i64 %12, ptr %4
br label exit
return:
br label exit
exit:
%13 = load i64, ptr %4
ret i64 %13
}


define internal @TestIntCalls void() {
entry:
%0 = call i64 1, 2, @Add__I__I
%1 = icmp eq i64 %0, 3
call i8 %1, @Assert
%2 = call i64 1, 2, 3, @AddThreeNumbers__I__I__I
%3 = icmp eq i64 %2, 6
call i8 %3, @Assert
%4 = call i64 1, 2, 3, 4, @AddFourNumbers__I__I__I__I
%5 = icmp eq i64 %4, 10
call i8 %5, @Assert
%6 = call i64 1, 2, 3, 4, 5, 6, @AddSixNumbers__I__I__I__I__I__I
%7 = icmp eq i64 %6, 21
call i8 %7, @Assert
%8 = call i64 1, 2, 3, 4, 5, 6, @AlternatingSum__I__I__I__I__I__I
%9 = icmp eq i64 %8, -3
call i8 %9, @Assert
br label exit
exit:
ret 
}


define internal @TestFloatCalls void() {
entry:
%0 = call f64 1, 2, @AddFloats__F__F
%1 = fcmp oeq f64 %0, 3
call i8 %1, @Assert
%2 = call i64 1, 2, 3, @AddIntAndFloat__I__F__F
%3 = fcmp oeq f64 %2, 6
call i8 %3, @Assert
%4 = call f64 1, 2, 3, 4, 1, @ConditionSum__F__F__F__F__B
%5 = fcmp oeq f64 %4, 3
call i8 %5, @Assert
%6 = call f64 1, 2, 3, 4, 0, @ConditionSum__F__F__F__F__B
%7 = fcmp oeq f64 %6, 7
call i8 %7, @Assert
br label exit
exit:
ret 
}


define internal @TestBoolCalls void() {
entry:
%0 = call i8 1, 0, 1, 0, @AddBooleans__B__B__B__B
%1 = icmp eq i64 %0, 2
call i8 %1, @Assert
br label exit
exit:
ret 
}


define external @main i64() {
entry:
%0 = alloca i64
call ptr @TestIntCalls
call ptr @TestFloatCalls
call ptr @TestBoolCalls
store 0, ptr %0
br label exit
return:
br label exit
exit:
%1 = load i64, ptr %0
ret i64 %1
}

