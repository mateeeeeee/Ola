Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @TestWhileLoopInt void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 1, ptr %1
br label while.cond
while.cond:
%2 = load i64, ptr %1
%3 = icmp sle i64 %2, 5
br i8 %3, label while.body, label while.end
while.body:
%4 = load i64, ptr %0
%5 = load i64, ptr %1
%6 = add i64 %4, %5
store i64 %6, ptr %0
%7 = load i64, ptr %1
%8 = alloca ptr
store i64 %7, ptr %8
%9 = add i64 %7, 1
store i64 %9, ptr %1
br label while.cond
while.end:
%10 = load i64, ptr %0
%11 = icmp eq i64 %10, 15
call i8 %11, @Assert
br label exit
exit:
ret 
}


define internal @TestWhileLoopBool void() {
entry:
%0 = alloca i8
store 1, ptr %0
%1 = alloca i64
store 0, ptr %1
br label while.cond
while.cond:
%2 = load i8, ptr %0
br i8 %2, label while.body, label while.end
while.body:
%3 = load i64, ptr %1
%4 = alloca ptr
store i64 %3, ptr %4
%5 = add i64 %3, 1
store i64 %5, ptr %1
%6 = load i64, ptr %1
%7 = icmp eq i64 %6, 3
br i8 %7, label if.then, label if.end
while.end:
%8 = load i64, ptr %1
%9 = icmp eq i64 %8, 3
call i8 %9, @Assert
br label exit
if.then:
store 0, ptr %0
br label if.end
if.else:
br label exit
if.end:
br label while.cond
exit:
ret 
}


define internal @TestNestedWhileLoops void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
br label while.cond
while.cond:
%2 = load i64, ptr %0
%3 = icmp slt i64 %2, 3
br i8 %3, label while.body, label while.end
while.body:
br label while.cond1
while.end:
%4 = load i64, ptr %0
%5 = icmp eq i64 %4, 3
call i8 %5, @Assert
%6 = load i64, ptr %1
%7 = icmp eq i64 %6, 2
call i8 %7, @Assert
br label exit
while.cond1:
%8 = load i64, ptr %1
%9 = icmp slt i64 %8, 2
br i8 %9, label while.body1, label while.end1
while.body1:
%10 = load i64, ptr %1
%11 = alloca ptr
store i64 %10, ptr %11
%12 = add i64 %10, 1
store i64 %12, ptr %1
br label while.cond1
while.end1:
%13 = load i64, ptr %0
%14 = alloca ptr
store i64 %13, ptr %14
%15 = add i64 %13, 1
store i64 %15, ptr %0
br label while.cond
exit:
ret 
}


define internal @TestWhileLoopWithBreak void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 1, ptr %1
br label while.cond
while.cond:
br label while.body
while.body:
%2 = load i64, ptr %0
%3 = load i64, ptr %1
%4 = add i64 %2, %3
store i64 %4, ptr %0
%5 = load i64, ptr %1
%6 = alloca ptr
store i64 %5, ptr %6
%7 = add i64 %5, 1
store i64 %7, ptr %1
%8 = load i64, ptr %1
%9 = icmp sgt i64 %8, 5
br i8 %9, label if.then, label if.end
while.end:
%10 = load i64, ptr %0
%11 = icmp eq i64 %10, 15
call i8 %11, @Assert
br label exit
if.then:
br label while.end
if.else:
br label exit
if.end:
br label while.cond
break:
br label exit
exit:
ret 
}


define internal @TestWhileLoopWithContinue void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
br label while.cond
while.cond:
%2 = load i64, ptr %1
%3 = icmp slt i64 %2, 5
br i8 %3, label while.body, label while.end
while.body:
%4 = load i64, ptr %1
%5 = alloca ptr
store i64 %4, ptr %5
%6 = add i64 %4, 1
store i64 %6, ptr %1
%7 = load i64, ptr %1
%8 = srem i64 %7, 2
%9 = icmp eq i64 %8, 0
br i8 %9, label if.then, label if.end
while.end:
%10 = load i64, ptr %0
%11 = icmp eq i64 %10, 9
call i8 %11, @Assert
br label exit
if.then:
br label while.cond
if.else:
br label exit
if.end:
%12 = load i64, ptr %0
%13 = load i64, ptr %1
%14 = add i64 %12, %13
store i64 %14, ptr %0
br label while.cond
continue:
br label exit
exit:
ret 
}


define internal @TestWhileLoopMultipleExits void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i8
store 0, ptr %1
br label while.cond
while.cond:
%2 = load i64, ptr %0
%3 = icmp slt i64 %2, 5
%4 = load i8, ptr %1
%5 = icmp eq i8 %4, 0
%6 = and i8 %3, %5
%7 = icmp ne i8 %6, 0
br i8 %7, label while.body, label while.end
while.body:
%8 = load i64, ptr %0
%9 = alloca ptr
store i64 %8, ptr %9
%10 = add i64 %8, 1
store i64 %10, ptr %0
%11 = load i64, ptr %0
%12 = icmp eq i64 %11, 3
br i8 %12, label if.then, label if.end
while.end:
%13 = load i64, ptr %0
%14 = icmp eq i64 %13, 3
call i8 %14, @Assert
%15 = load i8, ptr %1
call i8 %15, @Assert
br label exit
if.then:
store 1, ptr %1
br label if.end
if.else:
br label exit
if.end:
br label while.cond
exit:
ret 
}


define internal @TestWhileLoopExternalDeclaration void() {
entry:
%0 = alloca i64
store 0, ptr %0
%1 = alloca i64
store 0, ptr %1
br label while.cond
while.cond:
%2 = load i64, ptr %0
%3 = icmp slt i64 %2, 5
br i8 %3, label while.body, label while.end
while.body:
%4 = load i64, ptr %1
%5 = load i64, ptr %0
%6 = add i64 %4, %5
store i64 %6, ptr %1
%7 = load i64, ptr %0
%8 = alloca ptr
store i64 %7, ptr %8
%9 = add i64 %7, 1
store i64 %9, ptr %0
br label while.cond
while.end:
%10 = load i64, ptr %1
%11 = icmp eq i64 %10, 10
call i8 %11, @Assert
br label exit
exit:
ret 
}


define internal @TestWhileLoopWithCalculation void() {
entry:
%0 = alloca i64
store 10, ptr %0
%1 = alloca i64
store 0, ptr %1
br label while.cond
while.cond:
%2 = load i64, ptr %0
%3 = icmp sgt i64 %2, 0
br i8 %3, label while.body, label while.end
while.body:
%4 = load i64, ptr %0
%5 = sub i64 %4, 2
store i64 %5, ptr %0
%6 = load i64, ptr %1
%7 = alloca ptr
store i64 %6, ptr %7
%8 = add i64 %6, 1
store i64 %8, ptr %1
br label while.cond
while.end:
%9 = load i64, ptr %1
%10 = icmp eq i64 %9, 5
call i8 %10, @Assert
br label exit
exit:
ret 
}


define internal @TestWhileLoopFloatCondition void() {
entry:
%0 = alloca f64
store 0, ptr %0
%1 = alloca f64
store 0.1, ptr %1
br label while.cond
while.cond:
%2 = load f64, ptr %1
%3 = fcmp olt f64 %2, 0.99
br i8 %3, label while.body, label while.end
while.body:
%4 = load f64, ptr %0
%5 = load f64, ptr %1
%6 = fadd f64 %4, %5
store f64 %6, ptr %0
%7 = load f64, ptr %1
%8 = fadd f64 %7, 0.1
store f64 %8, ptr %1
br label while.cond
while.end:
%9 = load f64, ptr %0
%10 = fcmp ogt f64 %9, 4.49
%11 = load f64, ptr %0
%12 = fcmp olt f64 %11, 4.51
%13 = and i8 %10, %12
%14 = icmp ne i8 %13, 0
call i8 %14, @Assert
br label exit
exit:
ret 
}


define external @main i64() {
entry:
%0 = alloca i64
call ptr @TestWhileLoopInt
call ptr @TestWhileLoopBool
call ptr @TestNestedWhileLoops
call ptr @TestWhileLoopWithBreak
call ptr @TestWhileLoopWithContinue
call ptr @TestWhileLoopMultipleExits
call ptr @TestWhileLoopExternalDeclaration
call ptr @TestWhileLoopWithCalculation
call ptr @TestWhileLoopFloatCondition
store 0, ptr %0
br label exit
return:
br label exit
exit:
%1 = load i64, ptr %0
ret i64 %1
}

