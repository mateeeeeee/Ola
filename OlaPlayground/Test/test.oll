Module ID : test.ola

declare @Assert void(i8)


declare @AssertMsg void(i8,ptr)


define internal @GlobalIntX ptr 20


define internal @GlobalIntY ptr 4


define internal @GlobalFloatX ptr 7.5


define internal @GlobalFloatY ptr 2.5


define internal @TestMultiplication void() {
entry:
%0 = alloca i64
store 5, ptr %0
%1 = alloca i64
store 3, ptr %1
%2 = alloca f64
store 2.5, ptr %2
%3 = alloca f64
store 1.2, ptr %3
%4 = load i64, ptr %0
%5 = load i64, ptr %1
%6 = smul i64 %4, %5
%7 = alloca i64
store i64 %6, ptr %7
%8 = load i64, ptr %7
%9 = icmp eq i64 %8, 15
call i8 %9, @Assert
%10 = load f64, ptr %2
%11 = load f64, ptr %3
%12 = fmul f64 %10, %11
%13 = alloca f64
store f64 %12, ptr %13
%14 = load f64, ptr %13
%15 = fcmp oeq f64 %14, 3
call i8 %15, @Assert
%16 = load i64, ptr %0
%17 = load i64, ptr @GlobalIntY
%18 = smul i64 %16, %17
%19 = alloca i64
store i64 %18, ptr %19
%20 = load i64, ptr %19
%21 = icmp eq i64 %20, 20
call i8 %21, @Assert
%22 = load f64, ptr %2
%23 = load f64, ptr @GlobalFloatY
%24 = fmul f64 %22, %23
%25 = alloca f64
store f64 %24, ptr %25
%26 = load f64, ptr %25
%27 = fcmp oeq f64 %26, 6.25
call i8 %27, @Assert
%28 = load i64, ptr %0
%29 = smul i64 %28, 2
%30 = alloca i64
store i64 %29, ptr %30
%31 = load i64, ptr %30
%32 = icmp eq i64 %31, 10
call i8 %32, @Assert
%33 = load f64, ptr %2
%34 = fmul f64 %33, 2
%35 = alloca f64
store f64 %34, ptr %35
%36 = load f64, ptr %35
%37 = fcmp oeq f64 %36, 5
call i8 %37, @Assert
%38 = load i64, ptr @GlobalIntX
%39 = load i64, ptr @GlobalIntY
%40 = smul i64 %38, %39
%41 = alloca i64
store i64 %40, ptr %41
%42 = load i64, ptr %41
%43 = icmp eq i64 %42, 80
call i8 %43, @Assert
%44 = load f64, ptr @GlobalFloatX
%45 = load f64, ptr @GlobalFloatY
%46 = fmul f64 %44, %45
%47 = alloca f64
store f64 %46, ptr %47
%48 = load f64, ptr %47
%49 = fcmp oeq f64 %48, 18.75
call i8 %49, @Assert
%50 = load i64, ptr @GlobalIntX
%51 = smul i64 %50, 2
%52 = alloca i64
store i64 %51, ptr %52
%53 = load i64, ptr %52
%54 = icmp eq i64 %53, 40
call i8 %54, @Assert
%55 = load f64, ptr @GlobalFloatX
%56 = fmul f64 %55, 2
%57 = alloca f64
store f64 %56, ptr %57
%58 = load f64, ptr %57
%59 = fcmp oeq f64 %58, 15
call i8 %59, @Assert
call i8 1, @Assert
call i8 1, @Assert
%60 = load i64, ptr %0
%61 = smul i64 %60, 2
store i64 %61, ptr %0
%62 = load i64, ptr %0
%63 = icmp eq i64 %62, 10
call i8 %63, @Assert
%64 = load f64, ptr %2
%65 = fmul f64 %64, 1.5
store f64 %65, ptr %2
%66 = load f64, ptr %2
%67 = fcmp oeq f64 %66, 3.75
call i8 %67, @Assert
%68 = alloca i64
store 2, ptr %68
%69 = load i64, ptr %68
%70 = smul i64 %69, 3
store i64 %70, ptr %68
%71 = load i64, ptr %68
%72 = icmp eq i64 %71, 6
call i8 %72, @Assert
%73 = load i64, ptr @GlobalIntX
%74 = load i64, ptr @GlobalIntY
%75 = smul i64 %73, %74
store i64 %75, ptr @GlobalIntX
%76 = load i64, ptr @GlobalIntX
%77 = icmp eq i64 %76, 80
call i8 %77, @Assert
%78 = alloca i64
store 2, ptr %78
%79 = load i64, ptr @GlobalIntY
%80 = load i64, ptr %78
%81 = smul i64 %79, %80
store i64 %81, ptr @GlobalIntY
%82 = load i64, ptr @GlobalIntY
%83 = icmp eq i64 %82, 8
call i8 %83, @Assert
store 20, ptr @GlobalIntX
store 4, ptr @GlobalIntY
br label exit
exit:
ret 
}


define internal @TestDivision void() {
entry:
%0 = alloca i64
store 15, ptr %0
%1 = alloca i64
store 3, ptr %1
%2 = alloca f64
store 5, ptr %2
%3 = alloca f64
store 2, ptr %3
%4 = load i64, ptr %0
%5 = load i64, ptr %1
%6 = sdiv i64 %4, %5
%7 = alloca i64
store i64 %6, ptr %7
%8 = load i64, ptr %7
%9 = icmp eq i64 %8, 5
call i8 %9, @Assert
%10 = load f64, ptr %2
%11 = load f64, ptr %3
%12 = fdiv f64 %10, %11
%13 = alloca f64
store f64 %12, ptr %13
%14 = load f64, ptr %13
%15 = fcmp oeq f64 %14, 2.5
call i8 %15, @Assert
%16 = load i64, ptr %0
%17 = load i64, ptr @GlobalIntY
%18 = sdiv i64 %16, %17
%19 = alloca i64
store i64 %18, ptr %19
%20 = load i64, ptr %19
%21 = icmp eq i64 %20, 3
call i8 %21, @Assert
%22 = load f64, ptr %2
%23 = load f64, ptr @GlobalFloatY
%24 = fdiv f64 %22, %23
%25 = alloca f64
store f64 %24, ptr %25
%26 = load f64, ptr %25
%27 = fcmp oeq f64 %26, 2
call i8 %27, @Assert
%28 = load i64, ptr %0
%29 = sdiv i64 %28, 3
%30 = alloca i64
store i64 %29, ptr %30
%31 = load i64, ptr %30
%32 = icmp eq i64 %31, 5
call i8 %32, @Assert
%33 = load f64, ptr %2
%34 = fdiv f64 %33, 2
%35 = alloca f64
store f64 %34, ptr %35
%36 = load f64, ptr %35
%37 = fcmp oeq f64 %36, 2.5
call i8 %37, @Assert
%38 = load i64, ptr @GlobalIntX
%39 = load i64, ptr @GlobalIntY
%40 = sdiv i64 %38, %39
%41 = alloca i64
store i64 %40, ptr %41
%42 = load i64, ptr %41
%43 = icmp eq i64 %42, 5
call i8 %43, @Assert
%44 = load f64, ptr @GlobalFloatX
%45 = load f64, ptr @GlobalFloatY
%46 = fdiv f64 %44, %45
%47 = alloca f64
store f64 %46, ptr %47
%48 = load f64, ptr %47
%49 = fcmp oeq f64 %48, 3
call i8 %49, @Assert
%50 = load i64, ptr @GlobalIntX
%51 = sdiv i64 %50, 5
%52 = alloca i64
store i64 %51, ptr %52
%53 = load i64, ptr %52
%54 = icmp eq i64 %53, 4
call i8 %54, @Assert
%55 = load f64, ptr @GlobalFloatX
%56 = fdiv f64 %55, 2.5
%57 = alloca f64
store f64 %56, ptr %57
%58 = load f64, ptr %57
%59 = fcmp oeq f64 %58, 3
call i8 %59, @Assert
call i8 1, @Assert
call i8 1, @Assert
%60 = load i64, ptr %0
%61 = sdiv i64 %60, 2
store i64 %61, ptr %0
%62 = load i64, ptr %0
%63 = icmp eq i64 %62, 7
call i8 %63, @Assert
%64 = load f64, ptr %2
%65 = fdiv f64 %64, 2
store f64 %65, ptr %2
%66 = load f64, ptr %2
%67 = fcmp oeq f64 %66, 2.5
call i8 %67, @Assert
%68 = alloca f64
store 10, ptr %68
%69 = load f64, ptr %68
%70 = fdiv f64 %69, 2
store f64 %70, ptr %68
%71 = load f64, ptr %68
%72 = fcmp oeq f64 %71, 5
call i8 %72, @Assert
%73 = load f64, ptr @GlobalFloatX
%74 = load f64, ptr @GlobalFloatY
%75 = fdiv f64 %73, %74
store f64 %75, ptr @GlobalFloatX
%76 = load f64, ptr @GlobalFloatX
%77 = fcmp oeq f64 %76, 3
call i8 %77, @Assert
%78 = alloca f64
store 2, ptr %78
%79 = load f64, ptr @GlobalFloatY
%80 = load f64, ptr %78
%81 = fdiv f64 %79, %80
store f64 %81, ptr @GlobalFloatY
%82 = load f64, ptr @GlobalFloatY
%83 = fcmp oeq f64 %82, 1.25
call i8 %83, @Assert
store 7.5, ptr @GlobalFloatX
store 2.5, ptr @GlobalFloatY
br label exit
exit:
ret 
}


define internal @TestModulo void() {
entry:
%0 = alloca i64
store 17, ptr %0
%1 = alloca i64
store 4, ptr %1
%2 = load i64, ptr %0
%3 = load i64, ptr %1
%4 = srem i64 %2, %3
%5 = alloca i64
store i64 %4, ptr %5
%6 = load i64, ptr %5
%7 = icmp eq i64 %6, 1
call i8 %7, @Assert
%8 = load i64, ptr %0
%9 = load i64, ptr @GlobalIntY
%10 = srem i64 %8, %9
%11 = alloca i64
store i64 %10, ptr %11
%12 = load i64, ptr %11
%13 = icmp eq i64 %12, 1
call i8 %13, @Assert
%14 = load i64, ptr %0
%15 = srem i64 %14, 3
%16 = alloca i64
store i64 %15, ptr %16
%17 = load i64, ptr %16
%18 = icmp eq i64 %17, 2
call i8 %18, @Assert
%19 = load i64, ptr @GlobalIntX
%20 = load i64, ptr @GlobalIntY
%21 = srem i64 %19, %20
%22 = alloca i64
store i64 %21, ptr %22
%23 = load i64, ptr %22
%24 = icmp eq i64 %23, 0
call i8 %24, @Assert
%25 = load i64, ptr @GlobalIntX
%26 = srem i64 %25, 3
%27 = alloca i64
store i64 %26, ptr %27
%28 = load i64, ptr %27
%29 = icmp eq i64 %28, 2
call i8 %29, @Assert
%30 = srem i64 10, 3
%31 = icmp eq i64 %30, 1
call i8 %31, @Assert
%32 = load i64, ptr %0
%33 = srem i64 %32, 3
store i64 %33, ptr %0
%34 = load i64, ptr %0
%35 = icmp eq i64 %34, 2
call i8 %35, @Assert
br label exit
exit:
ret 
}


define internal @TestMixedTypeMultiplicationAndDivision void() {
entry:
%0 = alloca f64
store 1e-04, ptr %0
%1 = alloca i64
store 2, ptr %1
%2 = load i64, ptr %1
%3 = s2f i64 %2
%4 = load f64, ptr @GlobalFloatX
%5 = fmul f64 %3, %4
%6 = alloca f64
store f64 %5, ptr %6
%7 = load f64, ptr %6
%8 = fcmp ogt f64 %7, 14.9999
%9 = load f64, ptr %6
%10 = fcmp olt f64 %9, 15.0001
%11 = and i8 %8, %10
%12 = icmp ne i8 %11, 0
call i8 %12, @Assert
%13 = alloca f64
store 2.5, ptr %13
%14 = load i64, ptr @GlobalIntY
%15 = s2f i64 %14
%16 = load f64, ptr %13
%17 = fmul f64 %16, %15
%18 = alloca f64
store f64 %17, ptr %18
%19 = load f64, ptr %18
%20 = fcmp ogt f64 %19, 9.9999
%21 = load f64, ptr %18
%22 = fcmp olt f64 %21, 10.0001
%23 = and i8 %20, %22
%24 = icmp ne i8 %23, 0
call i8 %24, @Assert
%25 = alloca i64
store 5, ptr %25
%26 = load i64, ptr %25
%27 = s2f i64 %26
%28 = load f64, ptr @GlobalFloatY
%29 = fdiv f64 %27, %28
%30 = alloca f64
store f64 %29, ptr %30
%31 = load f64, ptr %30
%32 = fcmp ogt f64 %31, 1.9999
%33 = load f64, ptr %30
%34 = fcmp olt f64 %33, 2.0001
%35 = and i8 %32, %34
%36 = icmp ne i8 %35, 0
call i8 %36, @Assert
%37 = alloca f64
store 10, ptr %37
%38 = load i64, ptr @GlobalIntY
%39 = s2f i64 %38
%40 = load f64, ptr %37
%41 = fdiv f64 %40, %39
%42 = alloca f64
store f64 %41, ptr %42
%43 = load f64, ptr %42
%44 = fcmp ogt f64 %43, 2.4999
%45 = load f64, ptr %42
%46 = fcmp olt f64 %45, 2.5001
%47 = and i8 %44, %46
%48 = icmp ne i8 %47, 0
call i8 %48, @Assert
%49 = alloca i64
store 2, ptr %49
%50 = load i64, ptr %49
%51 = s2f i64 %50
%52 = load f64, ptr @GlobalFloatX
%53 = fmul f64 %51, %52
%54 = f2s f64 %53
store i64 %54, ptr %49
%55 = load i64, ptr %49
%56 = icmp eq i64 %55, 15
call i8 %56, @Assert
%57 = alloca f64
store 15, ptr %57
%58 = load i64, ptr %1
%59 = s2f i64 %58
%60 = load f64, ptr %57
%61 = fdiv f64 %60, %59
store f64 %61, ptr %57
%62 = load f64, ptr %57
%63 = fcmp ogt f64 %62, 7.4999
%64 = load f64, ptr %57
%65 = fcmp olt f64 %64, 7.5001
%66 = and i8 %63, %65
%67 = icmp ne i8 %66, 0
call i8 %67, @Assert
br label exit
exit:
ret 
}


define external @main i64() {
entry:
%0 = alloca i64
call ptr @TestMultiplication
call ptr @TestDivision
call ptr @TestModulo
call ptr @TestMixedTypeMultiplicationAndDivision
store 0, ptr %0
br label exit
return:
br label exit
exit:
%1 = load i64, ptr %0
ret i64 %1
}

