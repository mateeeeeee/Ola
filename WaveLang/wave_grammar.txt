

<translation-unit> ::= { import-declaration }* { <function_definition> | <function_declaration> | <variable-declaration> }*

<import-declaration> ::= import <identifier>;

<function_declaration>    ::= extern <type-specifier> <identifier>( <parameter-list> );
<function_definition>     ::= {<declaration_visibility>}? <type-specifier> <identifier>( <parameter-list> ) <compound_statement>
<declaration_visibility>  ::= public | private

<parameter-list> ::= <parameter-declaration>
                   | <parameter-list>, <parameter-declaration>

<parameter-declaration> ::= {<type-qualifier>}? <type-specifier> <declarator>

<declarator> ::= <identifier>

<type-qualifier> ::= {const}?
<type-specifier> ::= void
                   | bool  | bool {[]}+
                   | char  | char {[]}+
                   | int   | int  {[]}+
                   | float | float{[]}+
                   | <enum-specifier> | <enum-specifier>[]
                   | <class-specifier> | <class-specifier>[]
				   
<enum-specifier> ::= enum <identifier> { <enumerator-list> }
                   | enum { <enumerator-list> }
                   | enum <identifier>

<enumerator-list> ::= <enumerator>
                    | <enumerator-list> , <enumerator>

<enumerator> ::= <identifier>
               | <identifier> = <constant-expression>
			   
<class-specifier> ::= ... (TODO)

<constant-expression> ::= <conditional-expression>

<conditional-expression> ::= <logical-or-expression>
                           | <logical-or-expression> ? <expression> : <conditional-expression>

<logical-or-expression> ::= <logical-and-expression>
                          | <logical-or-expression> || <logical-and-expression>

<logical-and-expression> ::= <inclusive-or-expression>
                           | <logical-and-expression> && <inclusive-or-expression>

<inclusive-or-expression> ::= <exclusive-or-expression>
                            | <inclusive-or-expression> | <exclusive-or-expression>

<exclusive-or-expression> ::= <and-expression>
                            | <exclusive-or-expression> ^ <and-expression>

<and-expression> ::= <equality-expression>
                   | <and-expression> & <equality-expression>

<equality-expression> ::= <relational-expression>
                        | <equality-expression> == <relational-expression>
                        | <equality-expression> != <relational-expression>

<relational-expression> ::= <shift-expression>
                          | <relational-expression> < <shift-expression>
                          | <relational-expression> > <shift-expression>
                          | <relational-expression> <= <shift-expression>
                          | <relational-expression> >= <shift-expression>

<shift-expression> ::= <additive-expression>
                     | <shift-expression> << <additive-expression>
                     | <shift-expression> >> <additive-expression>

<additive-expression> ::= <multiplicative-expression>
                        | <additive-expression> + <multiplicative-expression>
                        | <additive-expression> - <multiplicative-expression>

<multiplicative-expression> ::= <unary-expression>
                              | <multiplicative-expression> * <unary-expression>
                              | <multiplicative-expression> / <unary-expression>
                              | <multiplicative-expression> % <unary-expression>
							 

<unary-expression> ::= <postfix-expression>
                     | ++ <unary-expression>
                     | -- <unary-expression>
                     | sizeof (<unary-expression>)
                     | sizeof (<type-specifier>)
                     | typeof (<expression>)

<postfix-expression> ::= <primary-expression>
                       | <postfix-expression> [ <expression> ]
                       | <postfix-expression> ( {<assignment-expression>}* )
                       | <postfix-expression> ++
                       | <postfix-expression> --

<primary-expression> ::= <identifier>
                       | <constant>
                       | <string>
                       | ( <expression> )

<constant> ::= <integer-constant>
             | <character-constant>
             | <floating-constant>
             | <enumeration-constant>
			 
<expression> ::= <assignment-expression>
               | <expression> , <assignment-expression>

<assignment-expression> ::= <conditional-expression>
                          | <unary-expression> <assignment-operator> <assignment-expression>

<assignment-operator> ::= =
                        | *=
                        | /=
                        | %=
                        | +=
                        | -=
                        | <<=
                        | >>=
                        | &=
                        | ^=
                        | |=

<unary-operator> ::= &
                   | *
                   | +
                   | -
                   | ~
                   | !

<variable-declaration> ::= {<type-qualifier>}? <type-specifier> <declarator> { = <initializer>}?;
                         | {<type-qualifier>}? var <declarator> = <initializer>;
	
<initializer> ::= <assignment-expression>

<compound-statement> ::= { {<variable-declaration>}* {<statement>}* }

<statement> ::= <labeled-statement>
              | <expression-statement>
              | <compound-statement>
              | <selection-statement>
              | <iteration-statement>
              | <jump-statement>

<labeled-statement> ::= <identifier> : <statement>
                      | case <constant-expression> : <statement>
                      | default : <statement>

<expression-statement> ::= {<expression>}? ;

<selection-statement> ::= if ( <expression> ) <statement>
                        | if ( <expression> ) <statement> else <statement>
                        | switch ( <expression> ) <statement>

<iteration-statement> ::= while ( <expression> ) <statement>
                        | do <statement> while ( <expression> ) ;
                        | for ( {<expression>}? ; {<expression>}? ; {<expression>}? ) <statement>

<jump-statement> ::= goto <identifier> ;
                   | continue ;
                   | break ;
                   | return {<expression>}? ; 
--------------------------------------------------------------------

int[] arr; -- not ok
var arr = {1,2,3,4}; //fine,  arr is of type int[4]
var arr = [4,0]; //fine,  arr is of type int[4]
int[] arr = int[5]{};
int[] arr = {1,2,3,4}; //fine, arr is of type int[4]
int[] arr = [4,0];	   //fine, arr is of type int[4] initialized with 4 zeroes

int[][] arr = {{1,2,3,4},{1,2,3,4}}; arr is of type int[2][4]